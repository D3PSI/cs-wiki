<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Microarchitecture (TODO)</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="61c2421c-67e9-433f-bf8f-28fd8b8099f8" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">💉</span></div><h1 class="page-title">Microarchitecture (TODO)</h1></header><div class="page-body"><nav id="a64a3eb6-22cc-474d-90f4-45015afac790" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fdcea117-72c4-4bbd-84c3-2a91f931faf4">Introduction</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bf9936ab-eff2-477b-8150-a357384e3e0d">Architectural State and Instruction Set</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2823b312-49c1-4dc6-8205-8f3ae7c30803">Design Process</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1b056381-eb61-44c8-a0df-1a844a9cc4ad">MIPS Microarchitectures</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#68e48017-06dc-4065-88e6-f93f65b9e37f">Performance Analysis</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4df2e432-151d-4bce-90fc-85b1e52f46a5">Single-Cycle Processor</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#30993a6b-259e-400e-9652-1256dc8c75cb">Single-Cycle Datapath</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fc076f88-1f9f-4141-888f-786e1a637ed6">Single-Cycle Control</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0fc7bea7-9c28-444b-a193-e2607c52f9e6">Performance Analysis</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#586774f1-c490-4748-8818-c5487c5a5be7">Multicycle Processor</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#475a2fb2-592a-4558-bf68-07aa5866b097">Multicycle Datapath</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fd94b87f-e5b7-42a7-823d-c89f56d78c24">Multicycle Control</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1b9173f2-8f42-470f-b280-107ba70e4195">Performance Analysis</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#adc3671a-0d84-4305-99cf-961b9e7b0184">Pipelined Processor</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fe751969-8445-4ebd-a055-5ee51dcdecb6">Pipelined Datapath</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#93d2ceda-289b-48f0-98b7-89856f62dd80">Pipelined Control</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ca875ab9-8309-4a55-8f9f-362121b11ee5">Hazards</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ec294776-913a-4b5a-b66f-4e3a6d913aa0">Solving Data Hazards with Forwarding</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e084575b-f249-442f-a0f1-00b2cc68bbf5">Solving Data Hazards With Stalls</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2469c4e9-d9f8-4065-abf7-6b5825c59493">Solving Control Hazards</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#577ac544-b934-4ab3-a1aa-63ad0e2b7902">Hazard Summary</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e6c4ea67-ab37-4e27-8481-29f58e46b1e7">Performance Analysis</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6372047d-370f-4a36-80ef-ecb47091ad17">HDL Representation</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d2249d1f-dbbb-4cd0-bf32-92da32911b6e">Single-Cycle Processor</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#786a4457-ed1a-4af2-b4ee-0756fa3c4192">Single-Cyle MIPS Processor</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#5929193e-203f-4cf8-a847-03d9b2914180">Controller</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e7fa3381-c37b-463f-b9b4-29dbd67bfbb7">Main Decoder</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#fea3c392-89a3-4811-b071-5068a5cff3da">ALU Decoder</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#533fb9f6-ff65-413d-917f-a5379f0eacab">Datapath</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e1542be4-b0c2-4734-9051-c66b00b0e668">Generic Building Blocks</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#57f708b6-69ec-4bd7-a79d-7641a25812e6">Register File</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d8c2d1fd-2b3b-49c9-8bb9-faab9e84f11b">Adder</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#715192a5-df34-466b-84b3-d780c923bf9a">Left Shift (Multiply by 4)</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#24a94da8-0e89-4c4a-8eb1-15257efe83a9">Sign Extension</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0665aca9-3842-4535-b216-3da311696ac3">Resettable Flip-Flop</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2f7d377b-8f19-4331-9131-7215b1cda271">2:1 Multiplexer</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5f375333-0612-41b8-b0f8-60818bd052f1">Testbench</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c9ae0377-5258-48e8-9b8f-4120514fe8cf">MIPS Testbench</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6e6f143e-201f-42b1-9524-317234008203">MIPS Top-Level Module</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#54113683-72d0-46a9-b5e1-3685b790f677">MIPS Data Memory</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2edf9025-f074-4bcf-8824-48210beee4dd">MIPS Instruction Memory</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e609874f-ed19-4a72-a220-2b7c97c7d205">Exceptions</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7621e8ed-f605-461f-9061-5143ff6e637d">Advanced Microarchitecture</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ba119328-337c-45bb-a624-15c50361fdca">Deep Pipelines</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9851a046-38f5-48e5-8a9d-f70c0802d484">Branch Prediction</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#af82484a-df23-4c3e-9470-e7bff36a8d12">Superscalar Processor</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b760bca4-c34d-41c0-8455-51fa1122625d">Out-of-Order Processor</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4668f61f-c2e7-437e-b7d8-21c38e3284d9">Register Renaming</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#57535c93-3083-4b2b-b97a-c0e2245c4bc8">Single Instruction Multiple Data</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0dc32615-0fee-478b-bf4d-f227e058673d">Multithreading</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#edcb45e0-fac9-4faf-8c7a-4015c349267c">Multiprocessors</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#07c4eb0f-18e3-4319-aa76-bb6b439696f5">IA-32 Microarchitecture</a></div></nav><h1 id="fdcea117-72c4-4bbd-84c3-2a91f931faf4" class="">Introduction</h1><p id="ecd26424-d998-468b-82b5-a3d8e0520b89" class="">This chapter covers <em>microarchitecture</em>, which is the connection between logic and architecture. Microarchitecture is the specific arrangement of registers, ALUs, finite state machines, memories and other logic building blocks needed to implement an architecture. A particular architecture, such as MIPS, may have many different microarchitectures, each with different trade-offs of performance, cost, and complexity. They all run the same programs, but their internal designs vary widely. We will design three different microarchitectures in this chapter to illustrate the trade-offs.</p><h2 id="bf9936ab-eff2-477b-8150-a357384e3e0d" class="">Architectural State and Instruction Set</h2><p id="505d7fc7-2485-47cc-98b8-08afe960c803" class="">Recall that a computer architecture is defined by its instruction set and <em>architectural state</em>. The architectural state for the MIPS processor consists of the program counter and the 32 registers. Any MIPS microarchitecture must contain all of this state. based on the current architectural state, the processor executes a particular instruction with a particular set of data to produce a new architectural state. Some microarchitectures contain additional <em>nonarchitectural state</em> to either simplify the logic or improve performance.</p><p id="eb063c32-840f-47f8-8d6b-c5288df655d5" class="">To keep the microarchitectures easy to understand, we consider only a subset of the MIPS instruction set. Specifically, we handle the following instructions:</p><ul id="16e5de60-9597-4946-a1a4-018bb2e92876" class="bulleted-list"><li style="list-style-type:disc">R-type arithmetic/logic instructions: <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>slt</code></li></ul><ul id="fb090130-a697-4e98-b09a-2b9fc7ccd9ea" class="bulleted-list"><li style="list-style-type:disc">Memory instructions: <code>lw</code>, <code>sw</code></li></ul><ul id="a7e2429b-e9ba-4485-b4c8-9ac25dc579d4" class="bulleted-list"><li style="list-style-type:disc">Branches: <code>beq</code></li></ul><p id="d7dfb094-bc67-45d7-970f-b3e0ea568b98" class="">After building the microarchitectures with these instructions, we extend them to handle <code>addi</code> and <code>j</code>. These particular instructions were chosen because they are sufficient to write many interesting programs. One one understands how to implement these instructions, one can expand the hardware to handle others.</p><h2 id="2823b312-49c1-4dc6-8205-8f3ae7c30803" class="">Design Process</h2><p id="f7949ef1-761a-4202-9ee6-0e2d0c556400" class="">We will divide our microarchitectures into two interacting parts: the <em>datapath</em> and the <em>control</em>. The datapath operates on words of data. It contains structures such as memories, registers, ALUs, and multiplexers. MIPS is a 32-bit architecture, so we will use a 32-bit datapath. The control unit receives the current instruction from the datapath and tells the datapath how to execute that instruction. Specifically, the control unit produces multiplexer select, register enable, and memory write signals to control the operation of the datapath.</p><div id="94e5cf2a-6dbd-47f3-8b49-b83f2870bd4f" class="column-list"><div id="3bd34080-2a26-4920-912f-c17462733940" style="width:62.5%" class="column"><p id="a94f2d90-1e69-4dcc-8dac-02afff0c49af" class="">A good way to design a complex system is to start with hardware containing the state elements. These elements include the memories and the architectural state (program counter and registers). Then, add blocks of combinational logic between the state elements to compute the new state based on the current state. The instruction is read from part of memory; load and store instructions then read or write data from another part of memory. Hence, it is often convenient to partition the overall memory into two smaller memories, one containing instructions and the other containing data. The figure shows a block diagram with the four state elements: the program counter, register file, and instruction and data memories.</p><p id="36f76ffa-4b8f-4595-a6e4-c31644659be5" class="">State elements usually have a reset input to put them into a known state at start-up. This reset is usually not shown.</p><p id="8db712d3-2131-411a-8710-08626d47e1d9" class="">The <em>program counter</em> is an ordinary 32-bit register. Its output, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PC</mtext></mrow><annotation encoding="application/x-tex">\text{PC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">PC</span></span></span></span></span></span><span>﻿</span></span>, points to the current instruction. Its input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>PC</mtext><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\text{PC}&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.825122em;vertical-align:0em;"></span><span class="mord"><span class="mord text"><span class="mord">PC</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.825122em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>, indicates the address of the next instruction.</p><p id="ead35e2a-544d-4bb1-bb38-3891feb2bef7" class="">The <em>instruction memory</em> has a single read port. It takes a 32-bit instruction address input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span>, and reads the 32-bit data (i.e., instruction) from that address onto the read data output, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext></mrow><annotation encoding="application/x-tex">\text{RD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span></span></span></span></span><span>﻿</span></span>.</p><p id="cf8b1268-1100-4288-9288-ce078be52f4b" class="">The 32-element <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 32-bit <em>register file</em> has two read ports and one write port. The read ports take 5-bit address inputs, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">A1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span></span></span></span></span><span>﻿</span></span> and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">A2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">2</span></span></span></span></span><span>﻿</span></span>, each specifying one of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5=32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">32</span></span></span></span></span><span>﻿</span></span> registers as source operands. They read the 32-bit register values onto read data outputs <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{RD}1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">1</span></span></span></span></span><span>﻿</span></span> and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">\text{RD}2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">2</span></span></span></span></span><span>﻿</span></span> respectively. The write port takes a 5-bit address input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">A3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>; a 32-bit write data input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext></mrow><annotation encoding="application/x-tex">\text{WD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span></span></span></span></span><span>﻿</span></span>; a write enable input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WE</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">\text{WE}3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WE</span></span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>; and a clock. If the write enable is 1, the register file writes the data into the specified register on the rising edge of the clock.</p><p id="30a5c843-0dc1-431e-9422-63ae8565392e" class="">The <em>data memory</em> has a single read/write port. If the write enable, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WE</mtext></mrow><annotation encoding="application/x-tex">\text{WE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WE</span></span></span></span></span></span><span>﻿</span></span>, is 1, it writes data <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext></mrow><annotation encoding="application/x-tex">\text{WD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span></span></span></span></span><span>﻿</span></span> into address <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span> on the rising edge of the clock. If the write enable is 0, it reads address <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span> onto <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext></mrow><annotation encoding="application/x-tex">\text{RD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span></span></span></span></span><span>﻿</span></span>.</p><p id="66fc2441-6698-48a4-ade8-7f9b9aa7d7e6" class="">The instruction memory, register file, and data memory are all read <em>combinationally</em>. In other words, if the address changes, the new data appears at <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext></mrow><annotation encoding="application/x-tex">\text{RD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span></span></span></span></span><span>﻿</span></span> after some propagation delay; no clock is involved. They are written only on the rising edge of the clock. In this fashion, the state of the system is changed only at the clock edge. The address, data, and write enable must be setup sometime before the clock edge and must remain stable until a hold time after the clock edge.Because the state elements change their state only on the rising edge of the clock, they are synchronous sequential circuits. The microprocessor is built of clocked state elements and combinational logic, so it too is a synchronous sequential circuit. Indeed, the processor can be viewed as a giant finite state machine, or as a collection of simpler interacting state machines.</p></div><div id="e1bf2b7d-c398-4eb7-84fb-8c06868f49f0" style="width:37.50000000000001%" class="column"><figure id="7b386e1b-95f7-447f-ad49-0165dd100ef9" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled.png"><img style="width:1167px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled.png"/></a></figure></div></div><h2 id="1b056381-eb61-44c8-a0df-1a844a9cc4ad" class="">MIPS Microarchitectures</h2><p id="147a4dbe-2179-4fe2-89a0-d5f7a980a873" class="">In this chapter, we develop three microarchitectures for the MIPS processor architecture: single-cycle, multi-cycle, and pipelined. They differ in the way that the state elements are connected together and in the amount of nonarchitectural state.</p><p id="fc79e88d-cb08-44b3-9559-299819efb553" class="">The <em>single-cycle microarchitecture</em> executes an entire instruction in one cycle. it is easy to explain and has a simple control unit. Because it completes the operation in one cycle, it does not require any nonarchitectural state. However, the cycle time is limited by the slowest instruction.</p><p id="8a30253d-7612-4435-8846-256e0836d637" class="">The <em>multicycle microarchitecture</em> executes instructions in a series of shorter cycles. Simpler instructions execute in fewer cycles than complicated ones. Moreover, the multicycle microarchitecture reduces the hardware cost by reusing expensive hardware blocks such as adders and memories. For example, the adder may be used on several different cycles for several purposes while carrying out a single instruction. The multicycle processor accomplishes this by adding several nonarchitectural registers to hold intermediate results. The multicycle processor executes only one instruction at a time, but each instruction takes multiple clock cycles.</p><p id="31a307d2-8884-4cdb-8c4f-7c6a96482e81" class="">The <em>pipelined microarchitecture</em> applies to pipelining to the single-cycle microarchitecture. It therefore can execute several instructions simultaneously, improving the throughput significantly. Pipelining must add logic to handle dependencies between simultaneously executing instructions. It also requires nonarchitectural pipeline registers. The added logic and registers are worthwhile; all commercial high-performance processors use pipelining today.</p><h1 id="68e48017-06dc-4065-88e6-f93f65b9e37f" class="">Performance Analysis</h1><p id="f3e19f8c-c68c-49a7-bd54-866a112f123a" class="">A particular processor architecture can have many microarchitectures with different cost and performance trade-offs. The cost depends on the amount of hardware required and the implementation technology. Each year, CMOS processes can pack more transistors on a chip for the same amount of money, and processors take advantage of these additional transistors to deliver more performance. Precise cost calculations require detailed knowledge of the implementation technology, but in general, more gates and more memory mean more dollars.</p><p id="a11e7ffe-9f61-4568-96c3-e66423984fce" class="">There are many ways to measure the performance of a computer system, and marketing departments are infamous for choosing the method that makes their computer look fastest, regardless of whether the measurement has any correlation to real world performance.</p><p id="98b35af2-ed39-45a3-ab1b-9f8df8d86e1c" class="">The only gimmick-free way to measure performance is by measuring the execution time of a program of interest to you. The computer that executes your program fastest has the highest performance. The next best choice is to measure the total execution time of a collection of programs that are similar to those you plan to run; this may be necessary if you haven’t written your program yet or if somebody else who doesn’t have your program is making the measurements. Such collections of programs are called <em>benchmarks</em>, and the execution times of these programs are commonly published to give some indication of how a processor performs.</p><p id="56b459fd-c6ec-4713-9ca6-fb9ec68de8ce" class="">The execution time of a program, measured in seconds, is given by below equation: </p><figure id="54e258cf-bfd2-400e-8a9a-8cfc6458889a" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Execution Time</mtext><mo>=</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><mtext># instructions</mtext><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><mfrac><mtext>cycles</mtext><mtext>instruction</mtext></mfrac><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><mfrac><mtext>seconds</mtext><mtext>seconds</mtext></mfrac><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo></mrow><annotation encoding="application/x-tex">\text{Execution Time}=\bigg( \text{\# instructions} \bigg) \bigg(\frac{\text{cycles}}{\text{instruction}} \bigg) \bigg( \frac{\text{seconds}}{\text{seconds}} \bigg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Execution Time</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mord text"><span class="mord"># instructions</span></span><span class="mord"><span class="delimsizing size3">)</span></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">instruction</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">cycles</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="delimsizing size3">)</span></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">seconds</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">seconds</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="delimsizing size3">)</span></span></span></span></span></span></div></figure><p id="087f5a71-2b5f-4e26-b43b-0a7e2e4725fc" class="">The number of instructions in a program depends on the processor architecture. Some architectures have complicated instructions that do more work per instruction, thus reducing the number of instructions in a program. However, these complicated instructions are often slower to execute in hardware. The number of instructions also depends enormously on the cleverness of the programmer.</p><p id="2f677c9d-0bb6-4080-92a8-d2b436f5ed52" class="">The number of cycles per instruction, often called <em>CPI</em>, is the number of clock cycles required to execute an average instruction. It is the reciprocal of the throughput (instructions per cycle, or <em>IPC</em>). Different microarchitectures have different CPIs. In these pages we will assume we have an ideal memory system that does not affect the CPI.</p><p id="488eb822-fff3-4d4f-82fd-69f10021023a" class="">The number of seconds per cycle is the clock period, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. The clock period is determined by the critical path through the logic on the processor. Different microarchitectures have different clock periods. Logic and circuit designs also significantly affect the clock period.</p><p id="f87beac7-4407-47be-b579-b56a823a23a8" class="">The challenge of the microarchitect is to choose the design that minimizes the execution time while satisfying constraints on cost and/or power consumption. Because microarchitectural decisions affect both CPI and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> and are influenced by logic and circuit designs, determining the best choice requires careful analysis. There are many other factors that affect overall computer performance. For example, the hard disk, the memory, the graphics system, and the network connection may be limiting factors that make processor performance irrelevant.</p><h1 id="4df2e432-151d-4bce-90fc-85b1e52f46a5" class="">Single-Cycle Processor</h1><p id="b14c6785-59c6-4a9d-b8c5-3142f5f90aab" class="">We first design a MIPS microarchitecture that executes instructions in a single cycle. We begin constructing the datapath by connecting the state elements from the above figure with combinational logic that can execute the various instructions. Control signals determine which specific instruction is carried out by the datapath at any given time. The controller contains combinational logic that generates the appropriate control signals based on the current instruction. We conclude by analyzing the performance of the single-cycle processor.</p><h2 id="30993a6b-259e-400e-9652-1256dc8c75cb" class="">Single-Cycle Datapath</h2><p id="61f7fc06-eb06-4b29-8f36-fc59b897cac0" class="">This section gradually develops the single-cycle datapath, adding one piece at a time to the state elements from the above figure. The new connections are emphasized in black (or blue, for new control signals), while the hardware that has already been studies is shown in gray.</p><div id="a31c9e48-10c4-4682-ad60-fb0754cfa325" class="column-list"><div id="f92c6d36-434b-4ef0-8c75-9b3f33fe7d69" style="width:62.5%" class="column"><p id="51a610e4-50d9-419e-8978-4c3b094ed920" class="">The program counter register contains the address of the instruction to execute. The first step is to read this instruction from instruction memory. The figure shows that the PC is simply connected to the address input of the instruction memory. The instruction memory reads out, or <em>fetches</em>, the 32-bit instruction, labeled <em>Instr</em>.</p><p id="d4316469-0338-490c-a12c-517716c2a2e0" class="">The processor’s actions depend on the specific instruction that was fetched, First we will work out the datapath connections for the <code>lw</code> instruction. The we will consider how to generalize the datapath to handle the other instructions.</p></div><div id="3d14fa62-560f-45b8-9581-2868ff89c6da" style="width:37.5%" class="column"><figure id="0935506d-1e82-4d72-84e8-89152ba47591" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%201.png"><img style="width:973px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%201.png"/></a></figure></div></div><div id="1085df00-b6a9-45d5-ad2f-6bea0d6115fd" class="column-list"><div id="e347e5ee-13c8-4b1f-98b3-284e185dc15f" style="width:62.5%" class="column"><p id="a5c3ac00-68dc-4199-a24a-41b90ebb724f" class="">For a <code>lw</code> instruction, the next step is to read the source register containing the base address. This register is specified in the <code>rs</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>25</mn><mo>:</mo><mn>21</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{25:21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span><span class="mrel mtight">:</span><span class="mord mtight">21</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. These bits of the instruction are connected to the address input of one of the register file read ports, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">A1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>, as shown in the figure. The register file reads the register value onto <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{RD}1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>.</p></div><div id="48307a30-70d5-40c6-a764-b2009f0b9cf7" style="width:37.50000000000001%" class="column"><figure id="ec44e450-5a21-4aec-981c-6e00dce6deb3" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%202.png"><img style="width:964px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%202.png"/></a></figure></div></div><div id="3da46379-6500-409f-bbbf-b1f6059a9707" class="column-list"><div id="989d85e6-f208-4745-b071-a45024fb1327" style="width:62.5%" class="column"><p id="0973adc5-a53f-4e67-8354-76545e42b7ec" class="">The <code>lw</code> instruction also requires an offset. The offset is stored in the immediate field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. Because the 16-bit immediate might be either positive or negative, it must be sign-extended to 32 bits, as shown in the figure. The 32-bit sign-extended value is called <em>SignImm</em>. Recall that sign extension simply copies the sign bit of a short input into all of the upper bits of the longer output.</p></div><div id="b5de8e9c-c540-45e1-8050-2b4066690fcb" style="width:37.49999999999999%" class="column"><figure id="84310356-3afe-4712-9f0f-800f049ce693" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%203.png"><img style="width:964px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%203.png"/></a></figure></div></div><div id="1ac80412-dae6-4563-9647-67576531c04d" class="column-list"><div id="b7ae53e8-5f98-47e1-8082-66e007acb293" style="width:62.5%" class="column"><p id="46d0aa68-9c79-46d7-82d3-c4b40572ec4c" class="">The processor must add the base address to the offset to find the address to read from memory. The figure introduces an ALU to perform this addition. The ALU receives two operands, <em>SrcA</em> and <em>SrcB</em>. <em>SrcA</em> comes from the register file, and <em>SrcB</em> comes from the sign-extended immediate. The ALU can perform many operations. The 3-bit <em>ALUControl</em> signal specifies the operation. The ALU generates a 32-bit <em>ALUResult</em> and a <em>Zero</em> flag, that indicates whether <em>ALUResult == 0</em>. For a <code>lw</code> instruction, the <em>ALUControl</em> signal should be set to 010 to add the base address and offset. <em>ALUResult</em> is sent to the data mmemory as the address for the load instruction, as shown.</p></div><div id="8a4df171-542b-4c0e-bbed-93ea246738b6" style="width:37.49999999999999%" class="column"><figure id="0c8855f7-a703-41c2-9f06-a96778f26e02" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%204.png"><img style="width:1278px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%204.png"/></a></figure></div></div><div id="b395cc56-a2a6-4e3f-95b9-c487811c4f66" class="column-list"><div id="1cb36623-dc11-421e-a1f5-8ebe44437256" style="width:62.5%" class="column"><p id="d28580f6-92f6-4437-b746-61031a8ee272" class="">The data is read from the data memory onto the <em>ReadData</em> bus, then written back to the destination register in the register file at the end of the cycle, as shown. Port 3 of the register file is the write port. The destination register for the <code>lw</code> instruction is specified in the <code>rt</code> field, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>20</mn><mo>:</mo><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{20:16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span><span class="mrel mtight">:</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>, which is connected to the port 3 address input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">A3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>, of the register file. The <em>ReadData</em> bus is connected to the port 3 write data input, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">\text{WD}3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>, of the register file. A control signal called <em>RegWrite</em> is connected to the port 3 write enable, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WE</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">\text{WE}3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WE</span></span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>, and is asserted during a <code>lw</code> instruction so that the data value is written into the register file. The write takes place on the rising edge of the clock at the end of the cycle.</p></div><div id="4ac6bda2-c08a-430e-a589-38fac210c848" style="width:37.49999999999999%" class="column"><figure id="914580c6-af85-4410-9b54-14450eeb18b2" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%205.png"><img style="width:1411px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%205.png"/></a></figure></div></div><div id="e703e776-0252-4d7f-8b3e-0e4b8a1378d9" class="column-list"><div id="f3fb9434-19c2-4435-b6c9-4cb10faa24f3" style="width:62.5%" class="column"><p id="660b77b6-0f13-4d4d-8b3f-1000b1ba947b" class="">While the instruction is being executed, the processor must compute the address of the next instruction, PC’. Because instructions are 32 bits = 4 bytes, the next instruction is at PC + 4. The figure uses another adder to increment the PC by 4. The new address is written into the program counter on the next rising edge of the clock. This completes the datapath for the <code>lw</code> instruction.</p></div><div id="a105cbf4-4ee0-4a07-8378-264ab4ca623f" style="width:37.5%" class="column"><figure id="7f14446c-1391-4c46-be82-51d01b8ce4e1" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%206.png"><img style="width:1504px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%206.png"/></a></figure></div></div><p id="72cade75-2806-474c-b1c2-a83d0133e636" class="">Next, let us extend the datapath to also handle the <code>sw</code> instruction. Like the <code>lw</code> instruction, the <code>sw</code> instruction reads a base address from port 1 of the register and sign-extends an immediate. The ALU adds the base address to the immediate to find the memory address. All of these functions are already supported by the datapath.</p><div id="52c9012f-b770-46ae-ad2f-6a9c6c211ca9" class="column-list"><div id="101fae2f-d113-4cf1-8fc7-e463f703278b" style="width:62.5%" class="column"><p id="cb19bcc5-9bbb-4060-99b7-ba60998012a8" class="">The <code>sw</code> instruction also reads a second register from the register file and writes it to the data memory. The figure shows the new connections for this function. The register is specified in the <code>rt</code> field, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>20</mn><mo>:</mo><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{20:16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span><span class="mrel mtight">:</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. These bits of the instruction are connected to the second register file read port, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">A2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">2</span></span></span></span></span><span>﻿</span></span>. The register value is read onto the <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">\text{RD}2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">2</span></span></span></span></span><span>﻿</span></span> port. It is connected to the write data port of the data memory. The write enable port of the data memory, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WE</mtext></mrow><annotation encoding="application/x-tex">\text{WE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WE</span></span></span></span></span></span><span>﻿</span></span>, is controlled by <em>MemWrite</em>. For a <code>sw</code> instruction, <em>MemWrite</em> = 1, to write the data to memory, <em>ALUControl</em> = 010, to add the base address and offset; and <em>RegWrite</em> = 0, because nothing should be written to the register file. Note that data is still read from the address given to the data memory, but that this <em>ReadData</em> is ignored because <em>RegWrite</em> = 0.</p><p id="35058d02-197f-4aaa-86c1-9674f12f6905" class="">Next, consider extending the datapath to handle the R-type instructions <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, and <code>slt</code>. All of these instructions read two registers from the register file, perform some ALU operation on them, and write the result back to a third register file. They differ only in the specific ALU operation. Hence, they can all be handled with the same hardware, using different <em>ALUControl</em> signals.</p></div><div id="6be30840-19ee-4ffa-b830-3a04fec02d0e" style="width:37.5%" class="column"><figure id="1c8e8f36-e2cc-4bab-b7f9-a538cea3f287" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%207.png"><img style="width:1492px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%207.png"/></a></figure></div></div><div id="8ae742ab-3b6e-4210-844d-bcc2dbc17869" class="column-list"><div id="2df0298c-c7a3-41d6-8187-cfbcca95ee5e" style="width:62.5%" class="column"><p id="1da95898-e669-4e21-87b6-6472be10be62" class="">The figure shows the enhanced datapath handling R-type instructions. The register file reads two registers. The ALU performs an operation on these two registers. Before, the ALU always received its <em>SrcB</em> operand from the sign-extended immediate. Now, we add a multiplexer to choose <em>SrcB</em> from either the register file <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">\text{RD}2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">2</span></span></span></span></span><span>﻿</span></span> port or <em>SignImm</em>.</p><p id="e6bbdf9f-872f-42d2-8f4d-147a1ff03f2e" class="">The multiplexer is controlled by a new signal, <em>ALUSrc</em>. <em>ALUSrc</em> is 0 for R-type instructions to choose <em>SrcB</em> from the register file; it is 1 for <code>lw</code> and <code>sw</code> to choose <em>SignImm</em>. This principle of enhancing the datapath’s capabilities by adding a multiplexer to choose inputs from several possibilities is extremely useful. Indeed, we will apply it twice more to complete the handling of R-type instructions.</p><p id="f0d595b6-076e-466e-98d7-a9a39b93257a" class="">Before, the register file always got its write data from the data memory. However, R-type instructions write the <em>ALUResult</em> to the register file. Therefore, we add another multiplexer to choose between <em>ReadData</em> and <em>ALUResult</em>. We call its output <em>Result</em>. This multiplexer is controlled by another new signal, <em>MemtoReg</em>. <em>MemtoReg</em> is 0 for R-type instructions to choose <em>Result</em> from the <em>ALUResult</em>; it is 1 for <code>lw</code> to choose <em>ReadData</em>. We don’t care about the value of <em>MemtoReg</em> for <code>sw</code>, because <code>sw</code> does not write to the register file.</p><p id="0fd36508-dfc7-430d-8d52-5e300b593d97" class="">Similarly, before, the register to write was specified by the <code>rt</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>20</mn><mo>:</mo><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{20:16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span><span class="mrel mtight">:</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. However, for R-type instructions, the register is specified by the <code>rd</code> field, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>11</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. Thus, we add a third multiplexer to choose <em>WriteReg</em> from the appropriate field of the instruction. The multiplexer is controlled by <em>RegDst</em>. <em>RegDst</em> is 1 for R-type instructions to choose <em>WriteReg</em> from the <code>rd</code> field, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>11</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>; it is 0 for <code>lw</code> to choose <em>ReadData</em>. We don’t care about the value of <em>MemtoReg</em> for <code>sw</code>, because <code>sw</code> does not write to the register file.</p><p id="0fdf55b0-6d37-4537-a247-f50c9c82b207" class="">Finally, let us extend the datapath to handle <code>beq</code>. <code>beq</code> compares two registers. If they are equal, it takes the branch by adding the branch offset to the program counter. Recall that the offset is a positive or negative number, stored in the <code>imm</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>31</mn><mo>:</mo><mn>26</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{31:26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span><span class="mrel mtight">:</span><span class="mord mtight">26</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. The offset indicates the number of instructions to branch past. Hence, the immediate must be sign-extended and multiplied by 4 to get the new program counter value: PC’ = PC + 4 + <em>SignImm</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 4.</p></div><div id="59df2836-01b4-42f7-9bb3-988981707c2a" style="width:37.5%" class="column"><figure id="4c870ec1-c9ce-4aba-9279-50594d682a12" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%208.png"><img style="width:1485px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%208.png"/></a></figure></div></div><div id="61675d8d-570c-4479-a11b-be7b5c1126c7" class="column-list"><div id="fe0d2567-c347-444f-a08c-8d163ee946e8" style="width:62.5%" class="column"><p id="d162879f-0d7d-4486-a2e6-d6e67b3623dd" class="">The figure shows the datapath modifications. The next PC value for a taken branch, <em>PCBranch</em>, is computed by shifting <em>SignImm</em> left by 2 bits, then adding it to <em>PCPlus4</em>. The left shift by 2 is an easy way to multiply by 4, because a shift by a constant amount involves just wires. The two registers are compared by computing <em>SrcA - SrcB</em> using the ALU. If <em>ALUResult</em> is 0, as indicated by the <em>Zero</em> flag from the ALU, the registers are equal. We add a multiplexer to choose PC’ from either <em>PCPlus4</em>, or <em>PCBranch</em>. <em>PCBranch</em> is selected if the instruction is a branch and the <em>Zero</em> flag is asserted. Hence, <em>Branch</em> is 1 for <code>beq</code> and 0 for other instructions. For <code>beq</code>, <em>ALUControl</em> = 110, so the ALU performs a subtraction. <em>ALUSrc</em> = 0 to choose <em>SrcB</em> from the register file. <em>RegWrite</em> and <em>MemWrite</em> are 0, because a branch does not write to the register file or memory. We don’t care about the values of <em>RegDst</em> and <em>MemtoReg</em>, because the register file is not written.</p><p id="d4519fa6-6480-49af-958a-7c9404c0d550" class="">This completes the design of the single-cycle MIPS processor datapath. We have illustrated not only the design, but the design process in which the state elements are identified and the combinational logic connecting the state elements is systematically added.</p></div><div id="5a31ca01-5438-46b1-97c8-655ac054b34a" style="width:37.5%" class="column"><figure id="d400e492-731b-471f-b174-301caebdc0db" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%209.png"><img style="width:1527px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%209.png"/></a></figure></div></div><h2 id="fc076f88-1f9f-4141-888f-786e1a637ed6" class="">Single-Cycle Control</h2><div id="278a9e2e-1eac-40f2-a4b7-0a57c0dee9f7" class="column-list"><div id="5f7ddd83-7c5c-4a01-89af-6bd58ff64561" style="width:62.5%" class="column"><p id="855e7c19-c66d-4603-b0b3-728d17b8b46f" class="">The control unit computes the control signals based on the <code>opcode</code> and <code>funct</code> fields of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>31</mn><mo>:</mo><mn>26</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{31:26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span><span class="mrel mtight">:</span><span class="mord mtight">26</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>5</mn><mo>:</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{5:0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mrel mtight">:</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. The figure shows the entire single-cycle MIPS processor with the control unit attached to the datapath.</p></div><div id="5168ae72-7d78-4d45-9a5b-53c2d5c26ea3" style="width:37.50000000000001%" class="column"><figure id="dfd826ce-8ac6-4317-9fa5-6504b1505f5c" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2010.png"><img style="width:1523px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2010.png"/></a></figure></div></div><div id="c09d0500-6454-4b27-8e13-0422f0c47b7c" class="column-list"><div id="091a5b84-793f-45f7-bac7-c7e1b8dc487f" style="width:81.25%" class="column"><p id="df9020da-ed8e-430b-b62a-33c71d59ad09" class="">Most of the control information comes from the <code>opcode</code>, but R-type instructions also use the <code>funct</code> field to determine the ALU operation. Thus, we will simplify our design by factoring the control unit into two blocks of combinational logic, as shown in the figure. The <em>main decoder</em> computes most of the outputs from the <code>opcode</code>. It also determines a 2-bit <em>ALUOp</em> signal. The ALU decoder uses this <em>ALUOp</em> signal in conjunction with the <code>funct</code> field to compute <em>ALUControl</em>.</p></div><div id="de34c6b3-afd8-4db2-b08f-c6113a8e98ea" style="width:18.750000000000004%" class="column"><figure id="e7241da3-b034-45fe-ac06-8b9666011c41" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2011.png"><img style="width:439px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2011.png"/></a></figure></div></div><div id="e1bc1363-54ce-4388-8082-3b47bb47437e" class="column-list"><div id="90d20bc3-c8d6-4da9-bc9a-ebc64f333a03" style="width:75%" class="column"><p id="8e1b0ad7-db04-477d-9801-267518dfb6c9" class="">The meaning of the <em>ALUOp</em> signal is given in the table.</p></div><div id="e53d263e-2bbd-4f5a-866e-baec53b4d19e" style="width:25.000000000000007%" class="column"><figure id="72c025e5-11b5-49b9-b43a-a85dec09f6fd" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2012.png"><img style="width:538px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2012.png"/></a></figure></div></div><div id="3f3efe5a-9fda-42ae-b2e1-26e1932d6922" class="column-list"><div id="5cbbab2b-dca2-449a-b4f1-920b9c83fa47" style="width:75%" class="column"><p id="079f1473-9b0a-4ed2-8276-dd9aaf23a476" class="">The table is a truth table for the ALU decoder. Recall that the meaning of the three <em>ALUControl</em> signals were given earlier, when we designed the ALU. Because <em>ALUOp</em> is never 11, the truth table can use don’t care’s X1 and 1X instead of 01 and 10 to simplify the logic. When <em>ALUOp</em> is 00 or 01, the ALU should add or subtract, respectively. When <em>ALUOp</em> is 10, the decoder examines the <code>funct</code> field to determine the <em>ALUControl</em>. Note that, for the R-type instructions we implement, the first two bits of the <code>funct</code> field are always 10, so we may ignore them to simplify the decoder.</p></div><div id="310f9027-b2fd-4359-83de-ad8fe2c4aaa6" style="width:25.000000000000007%" class="column"><figure id="e630600f-e497-4d31-806e-3f64c08465ab" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2013.png"><img style="width:903px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2013.png"/></a></figure></div></div><div id="12262152-c4ed-407a-90bf-e114b919b61b" class="column-list"><div id="c8f19dad-b970-41e2-a22c-479e74618e3e" style="width:56.25%" class="column"><p id="a7264654-4443-4b23-8c2e-79d4db9ce9b6" class="">The control signals for each instruction were described as we built the datapath. The table is a truth table for the main decoder that summarizes the control signals as a function of the opcode. All R-type instructions use the same main decoder values; they differ only in the ALU decoder output. Recall that, for instructions that do not write to the register file, the <em>RegDst</em> and <em>MemtoReg</em> control signals are don’t cares; the address and data to the register write port do not matter because <em>RegWrite</em> is not asserted.</p></div><div id="93b165bf-a10c-42b3-80f1-0636f32c0613" style="width:43.75%" class="column"><figure id="b72cb68d-5155-48bb-9714-a99dc7cff272" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2014.png"><img style="width:1643px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2014.png"/></a></figure></div></div><h2 id="0fc7bea7-9c28-444b-a193-e2607c52f9e6" class="">Performance Analysis</h2><div id="0fa1fbf3-58a4-472d-b960-613777574989" class="column-list"><div id="42f08fed-f29e-4ef8-8338-a8cab0c4c797" style="width:56.25%" class="column"><p id="87ecb135-dfb9-46d1-aeca-81cc8663cd21" class="">Each instruction in the single-cycle processor takes one clock cycle, so the CPI is 1. The critical path for the <code>lw</code> instruction is shown in the figure with a heavy dashed blue line. It starts with the PC loading a new address on the rising edge of the clock. The instruction memory reads the next instruction. The register file reads <em>SrcA</em>. While the register file is reading, the immediate field is sign-extended and selected at the <em>ALUSrc</em> multiplexer to determine <em>SrcB</em>. The ALU adds <em>SrcA</em> and <em>SrcB</em> to find the effective address<em>. </em>The data memory reads from this address. The <em>MemtoReg</em> multiplexer selects <em>ReadData</em>. Finally, <em>Result</em> must setup at the register file before the next rising clock edge, so that it can be properly written. Hence, the cycle time is</p><figure id="f7e03f49-4cdd-4ba0-8e27-e1ec513748c9" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub><mo>=</mo><msub><mi>T</mi><mrow><mi>p</mi><mi>c</mi><mi>q</mi><mi mathvariant="normal">_</mi><mtext>PC</mtext></mrow></msub><mo>+</mo><msub><mi>t</mi><mtext>mem</mtext></msub><mo>+</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mrow><mi>R</mi><msub><mi>F</mi><mtext>read</mtext></msub></mrow></msub><mo separator="true">,</mo><msub><mi>t</mi><mtext>sign-ext</mtext></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>t</mi><mtext>mux</mtext></msub><mo>+</mo><msub><mi>t</mi><mtext>ALU</mtext></msub><mo>+</mo><msub><mi>t</mi><mtext>mem</mtext></msub><mo>+</mo><msub><mi>t</mi><mtext>mux</mtext></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>R</mi><mi>F</mi><mtext>setup</mtext></mrow></msub></mrow><annotation encoding="application/x-tex">T_c = T_{pcq\_\text{PC}}+t_{\text{mem}}+ \max (t_{RF_{\text{read}}}, t_{\text{sign-ext}}) + t_{\text{mux}} + t_{\text{ALU}} + t_{\text{mem}} + t_{\text{mux}} + t_{RF\text{setup}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord text mtight"><span class="mord mtight">PC</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mem</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">read</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">sign-ext</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mux</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">ALU</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mem</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mux</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RF</span><span class="mord text mtight"><span class="mord mtight">setup</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="8bc701c4-1b4b-46a7-bed1-035fb4e22422" class="">In most implementation technologies, the ALU, memory, and register file accesses are substantially slower than other operations. Therefore, the cycle time simplifies to </p><figure id="4bca097a-f48c-425e-b930-4034cbb9e86d" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>p</mi><mi>c</mi><mi>q</mi><mi mathvariant="normal">_</mi><mtext>PC</mtext></mrow></msub><mo>+</mo><mn>2</mn><msub><mi>t</mi><mtext>mem</mtext></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>R</mi><mi>F</mi><mtext>read</mtext></mrow></msub><mo>+</mo><mn>2</mn><msub><mi>t</mi><mtext>mux</mtext></msub><mo>+</mo><msub><mi>t</mi><mtext>ALU</mtext></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>R</mi><mi>F</mi><mtext>setup</mtext></mrow></msub></mrow><annotation encoding="application/x-tex">T_c = t_{pcq\_\text{PC}} + 2t_{\text{mem}} + t_{RF\text{read}} + 2 t_{\text{mux}} + t_{\text{ALU}} + t_{RF\text{setup}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.98208em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord text mtight"><span class="mord mtight">PC</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mem</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RF</span><span class="mord text mtight"><span class="mord mtight">read</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mux</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">ALU</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RF</span><span class="mord text mtight"><span class="mord mtight">setup</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="6c507b3a-1984-44d1-930e-e39cafdc619c" class="">The numerical values of these times will depend on the specific implementation technology. Other instructions have shorter critical paths. For example, R-type instructions do not need to access data memory. However, we are disciplining ourselves to synchronous sequential design, so the clock period is constant and must be long enough to accommodate  the slowest instruction.</p></div><div id="72e90c04-abda-471d-a8c0-c72160194345" style="width:43.75%" class="column"><figure id="ceccad64-03e2-4444-b22a-b731b69a14d4" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2015.png"><img style="width:1529px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2015.png"/></a></figure></div></div><h1 id="586774f1-c490-4748-8818-c5487c5a5be7" class="">Multicycle Processor</h1><p id="f53a1b9e-efc5-4e25-b32a-0da5498993bd" class="">The single-cycle processor has three primary weaknesses. First, it requires a clock cycle long enough to support the slowest instruction, even though most instructions are faster. Second, it requires three adders; adders are relatively expensive circuits, especially if they must be fast. And third, it has separate instruction and data memories, which may not be realistic. Most computers have a single large memory that holds both instructions and data and that can be read and written.</p><p id="6e070409-0a5c-4343-8cf0-d3e1ffe0a234" class="">The multicycle processor addresses these weaknesses by breaking an instruction into multiple shorter steps. In each short step, the processor can read or write the memory or register file or use the ALU. Different instructions use different numbers of steps, so simpler instructions can complete faster than more complex ones. The processor needs only one adder; this adder is reused for different purposes on various steps. And the processor uses a combined memory for instructions and data. The instruction is fetched from memory on the first step, and data may be read or written on later steps.</p><p id="212f581a-636d-40a1-b4d1-31eb72735b16" class="">We design a multicycle processor following the same procedure we used for the single-cycle processor. First, we construct a datapath by connecting the architectural state elements and memories with combinational logic. But, this time, we also add nonarchitectural state elements to hold intermediate results between the steps. Then we design the controller. The controller produces different signals on different steps during execution of a single instruction, so it is now a finite state machine rather than combinational logic. We again examine how to add new instructions to the processor. Finally, we analyze the performance of the multicycle processor and compare it to the single-cycle processor.</p><h2 id="475a2fb2-592a-4558-bf68-07aa5866b097" class="">Multicycle Datapath</h2><div id="1f1bd536-93ab-46a0-b24d-c9e8357dd199" class="column-list"><div id="79a244ff-ee45-4348-89fe-1e663c83b8a9" style="width:56.25%" class="column"><p id="6a3ddd45-0dc8-4fcc-9ca3-f740609a3324" class="">Again, we begin our design with the memory and architectural state of the MIPS processor, as shown in the figure. In the single-cycle design, we used separate instruction and data memories because we needed to read the instruction memory and read or write the data memory all in one cycle. Now, we choose to use a combined memory for both instructions and data. This is more realistic, and it is feasible because we can read the instruction in one cycle, then read or write the data in a separate cycle. The PC and register file remain unchanged. We gradually build the datapath by adding components to handle each step of each instruction. The new connections are emphasized in black (or blue for new control signals), whereas the hardware that has already been studied is shown in gray.</p></div><div id="4ed9d58f-cd09-4528-8dd9-044f7f4cd871" style="width:43.74999999999999%" class="column"><figure id="8a389b8f-3270-4b25-b3b4-67fa8dd5317b" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2016.png"><img style="width:848px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2016.png"/></a></figure></div></div><div id="87b93486-a55d-4ef8-b4cf-06ed20f3b6dd" class="column-list"><div id="f12c2a65-44ec-4baa-b69e-68ba617666f4" style="width:56.25%" class="column"><p id="a2dd0668-7b6d-4604-a811-bccf65aa4f16" class="">The PC contains the address of the instruction to execute. The first step is to read this instruction from instruction memory. The figure shows that the PC is simply connected to the address input of the instruction memory. The instruction is read and stored in a new nonarchitectural Instruction Register so that it is available for future cycles. The Instruction Regiter receives an enable signal, called <em>IRWrite</em>, that is asserted when it should be updated with a new instruction.</p></div><div id="f7ebbefd-1add-4d4d-9708-dfb7e1fdcf3d" style="width:43.75%" class="column"><figure id="3e664acf-f78d-4937-b10e-231b0ec0638f" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2017.png"><img style="width:941px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2017.png"/></a></figure></div></div><div id="0a1aa63f-b6c7-4dbf-909c-b6a74552a587" class="column-list"><div id="0ceb1c82-d414-4b94-94ec-16f2149a3afe" style="width:56.25%" class="column"><p id="3f3c507e-1880-40dc-a35e-f7476d529a7d" class="">As we did with the single-cycle processor, we will work out the datapath connections for the <code>lw</code> instruction. Then we will enhance the datapath to handle the other instructions. For a <code>lw</code> instruction, the next step is to read the source register containing the base address. This register is specified in the <code>rs</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>25</mn><mo>:</mo><mn>21</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{25:21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span><span class="mrel mtight">:</span><span class="mord mtight">21</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. These bits of the instruction are connected to one of the address inputs, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">A1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>, of the register file, as shown in the figure.  The register file reads the register onto <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RD</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{RD}1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">RD</span></span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>. This value is stored in another nonarchitectural register, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span>.</p></div><div id="c4537fcf-baf7-4b71-a2d2-38d2e68d8798" style="width:43.75%" class="column"><figure id="3cd87bdd-62d1-4aa0-8f29-0fd4e86d9a68" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2018.png"><img style="width:1052px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2018.png"/></a></figure></div></div><div id="38ae76da-d2f2-4d50-bda4-78ea506f96aa" class="column-list"><div id="b6468f33-bb29-4b09-8ab1-ea241e0087ac" style="width:56.25%" class="column"><p id="1786ade4-7b08-4b76-9127-1980c4446b0a" class="">The <code>lw</code> instruction also requires an offset. The offset is stored in the immediate field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> and must be sign-extended to 32-bits, as shown. The 32-bit sign-extended value is called <em>SignImm</em>. To be consistent, we might store <em>SignImm</em> in another nonarchitecural register. However, <em>SignImm</em> is a combinational function of <em>Instr</em> and will not change while the current instruction is being processed, so there is no need to dedicate a register to hold the constant value.</p></div><div id="f8f7e7fe-1aa9-462e-b978-e34f560f6d73" style="width:43.75%" class="column"><figure id="4004d13a-a173-4096-9c12-a8b3439aed53" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2019.png"><img style="width:1019px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2019.png"/></a></figure></div></div><div id="c7c2dcdc-20b2-401c-bb07-2e99cf96a1c5" class="column-list"><div id="6ab79234-9d72-4287-ba8b-c977fe1f4a8d" style="width:56.25%" class="column"><p id="0e683b7e-fb3e-4db5-af42-7dd97b32beb3" class="">The address of the load is the sum of the base address and offset. We use an ALU to compute this sum, as shown in the figure. <em>ALUControl</em> should be set to 010 to perform an addition. <em>ALUResult</em> is stored in a nonarchitectural register called <em>ALUOut</em>.</p></div><div id="22785c7e-92b4-4186-8686-d4c53b984eae" style="width:43.75%" class="column"><figure id="b96fbd37-2fc9-4a0e-a313-75db8f6115eb" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2020.png"><img style="width:1579px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2020.png"/></a></figure></div></div><div id="96a15215-8ce6-4879-808c-daf2cbd50597" class="column-list"><div id="3ed0279b-20e2-4508-9a86-3df6d2d164d6" style="width:56.25%" class="column"><p id="c7ab93e7-4fe2-412c-9b80-ad797769c5d8" class="">The next step is to load the data from the calculated address in the memory. We add a multiplexer in front of the memory to choose the memory address, <em>Adr</em>, from either the PC or <em>ALUOut</em>, as shown in the figure. The multiplexer select signal is called <em>IorD</em>, to indicate either an instruction or data address. The data read from the memory is stored in another nonarchitectural register called <em>Data</em>. Notice that the address multiplexer permits the reuse of the memory during the <code>lw</code> instruction. On the first step, the address is taken from <em>ALUOut</em> to load the data. Hence, <em>IorD</em> must have different values on different steps. We develop the FSM controller that generates these sequences of control signals later.</p></div><div id="414b5e50-2b44-40a6-a83f-ce3fb8b83a0a" style="width:43.75000000000001%" class="column"><figure id="9a7ef3fb-508f-41e0-a753-319900010a8c" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2021.png"><img style="width:1546px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2021.png"/></a></figure></div></div><div id="84f7556a-c918-4054-90f4-6652f07fc816" class="column-list"><div id="d3ecea54-1508-437a-8444-54b0bc4321f1" style="width:56.25%" class="column"><p id="5b362dab-1fea-4235-8954-6e4b6fceffe4" class="">Finally, the data is written back to the register file, as shown in the figure. The destination register is specified by the <code>rt</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>20</mn><mo>:</mo><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{20:16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span><span class="mrel mtight">:</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>.</p></div><div id="b7a13015-c874-450b-80e8-1ba4fdf30ffd" style="width:43.75000000000001%" class="column"><figure id="25dcc3e4-b48c-4a7e-a461-f213a2d5c975" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2022.png"><img style="width:1654px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2022.png"/></a></figure></div></div><div id="10fef259-ec0b-49c0-9481-ca6b3d7d0f70" class="column-list"><div id="1ab5662e-081c-471e-a775-3d3bea14aafd" style="width:56.25%" class="column"><p id="f8830590-5fff-44a1-80ff-a79bb56c9dfb" class="">While all this is happening, the processor must update the program counter by adding 4 to the old PC. In the single-cycle processor, a separate adder was needed. In the multicycle processor, we can use the existing ALU on one of the steps when it is not busy. To do so, we must insert source multiplexers to choose the PC and the constant 4 as ALU inputs, as shown in the figure. A two-input multiplexer controlled by <em>ALUSrcA</em> chooses either the PC or register <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span> as <em>SrcA</em>. A four-input multiplexer controlled by <em>ALUSrcB</em> chooses either 4 or <em>SignImm</em> as <em>SrcB</em>. We use the other two multiplexer inputs later when we extend the datapath to handle other instructions. To update the PC, the ALU adds <em>SrcA</em> (PC) to <em>SrcB</em> (4), and the result is written back into the program counter register. The <em>PCWrite</em> control signal enables the PC register to be written only on certain cycles.</p><p id="112a0862-c947-4d28-894a-0c8da690e063" class="">This completes the datapath for the <code>lw</code> instruction. Next, let’s extend the datapath to also handle the <code>sw</code> instruction. Like the <code>lw</code> instruction, the <code>sw</code> instruction reads a base address from port 1 of the register file and sign-extends the immediate. The ALU adds the base address to the immediate to find the memory address.</p></div><div id="25bda2b3-fae2-4284-8511-1dda514aa33e" style="width:43.75000000000001%" class="column"><figure id="14a97661-67e9-4a6a-bf60-621e251b6ca1" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2023.png"><img style="width:1553px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2023.png"/></a></figure></div></div><div id="a5a8f518-8c2a-475f-b2bf-12c7edff1b4d" class="column-list"><div id="63a2436e-97fb-4a8b-9b8f-f98b06fc0570" style="width:56.25%" class="column"><p id="032d3000-bdd0-4a18-b941-4826e4abceac" class="">The only new feature of <code>sw</code> is that we must read a second register from the register file and write it into the memory, as shown in the figure. The register is specified in the <code>rt</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>20</mn><mo>:</mo><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{20:16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span><span class="mrel mtight">:</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>, which is connected to the second port of the register file. When the register is read, it is stored in a nonarchitectural register, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span><span>﻿</span></span>. On the next step, it is sent to the write data port (<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext></mrow><annotation encoding="application/x-tex">\text{WD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span></span></span></span></span><span>﻿</span></span>) of the data memory to be written. The memory receives an additional <em>MemWrite</em> control signal to indicate that the write should occur.</p></div><div id="cee20a92-2bb7-4194-8c2c-0a4844647659" style="width:43.74999999999999%" class="column"><figure id="710ba91d-f155-40e7-8e9e-c8cb9b3fd685" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2024.png"><img style="width:1673px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2024.png"/></a></figure></div></div><div id="ba325f13-c8a7-4b28-819d-6949ac2b19c1" class="column-list"><div id="83f5bf3b-4bfd-4b8e-8970-17d494944644" style="width:56.25%" class="column"><p id="15262457-3819-4c84-ae12-2cc12f6e6352" class="">For R-type instructions, the instruction is again fetched, and the two source registers are read from the register file. Another input of the <em>SrcB</em> multiplexer is used to choose register <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>B</mtext></mrow><annotation encoding="application/x-tex">\text{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">B</span></span></span></span></span></span><span>﻿</span></span> as the second source register for the ALU, as shown. The ALU performs the appropriate operation and stores the result in <em>ALUOut</em>. On the next step, <em>ALUOut</em> is written back to the register specified by the <code>rd</code> field of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>11</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. This requires two new multiplexers. The <em>MemtoReg</em> multiplexer selects whether <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">\text{WD}3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span><span class="mord">3</span></span></span></span></span><span>﻿</span></span> comes from <em>ALUOut</em> (for R-type instructions) or from <em>Data</em> (for <code>lw</code>). The <em>RegDst</em> instruction selects whether the destination register is specified in the <code>rt</code> or <code>rd</code> field of the instruction.</p></div><div id="78c59e06-9cde-4374-95e4-0fce6260ebf7" style="width:43.75%" class="column"><figure id="124035bf-adcb-4094-bbf8-497b42a74e51" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2025.png"><img style="width:1532px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2025.png"/></a></figure></div></div><div id="07086cd0-cf43-4920-890d-51a061edb040" class="column-list"><div id="8b80e196-449a-4c43-98df-35e60e8b8a40" style="width:56.25%" class="column"><p id="cc45e577-1571-4927-b926-5c53028c03e9" class="">For the <code>beq</code> instruction, the instruction is again fetched, and the two source registers are read from the register file. To determine whether the registers are equal, the ALU subtracts the registers and examines the <em>Zero</em> flag. Meanwhile, the datapath must compute the next value of the PC if the branch is taken: PC’ = PC + 4 + <em>SignImm</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 4. In the single-cycle processor, yet another adder was needed to compute the branch address. In the multicycle processor, the ALU can be reused again to save hardware. On one step, the ALU computers PC + 4 and writes it back to the program counter, as was done for other instructions. On another step, the ALU uses this updated PC value to compute PC + <em>SignImm</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 4. <em>SignImm</em> is left-shifted by 2 to multiply it by 4, as shown. The <em>SrcB</em> multiplexer chooses this value and add it to the PC. This sum represents the destination of the branch and is stored in <em>ALUOut</em>. A new multiplexer, controlled by <em>PCSrc</em>, chooses what signal should be sent to PC’. The program counter should be written either when <em>PCWrite</em> is asserted or when a branch is taken. A new control signal, <em>Branch</em>, indicates that the <code>beq</code> instruction is being executed. The branch is taken if <em>Zero</em> is also asserted. Hence, the datapath computes a new PC write enable, called <em>PCEn</em>, which is TRUE either when <em>PCWrite</em> is asserted or when both <em>Branch</em> and <em>Zero</em> are asserted.</p><p id="c212799c-ca67-4970-8af4-eeab181f3d0e" class="">This completes the design of the multicycle MIPS processor datapath. The design process is much like that of the single-cycle processor in that hardware is systematically connected between the state elements to handle each instruction. The main difference is that the instruction is executed in several steps. Nonarchitectural registers are inserted to hold the results of each step. In this way, the ALU can be reused several times, saving the cost of extra adders. Similarly, the instructions and data can be stored in one shared memory.</p></div><div id="8b1daa14-d259-4cf4-a03d-85772c2973b3" style="width:43.74999999999999%" class="column"><figure id="f7d46f98-c0dd-4079-a6c6-390bdeff74ca" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2026.png"><img style="width:1535px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2026.png"/></a></figure></div></div><h2 id="fd94b87f-e5b7-42a7-823d-c89f56d78c24" class="">Multicycle Control</h2><div id="e476e816-f08d-47db-9c56-2dc159ef398f" class="column-list"><div id="bc073fa7-133e-4ca1-b8a0-a1157264fe38" style="width:56.25%" class="column"><p id="63c22849-4ef5-4fb2-b8ee-f8fc645f6c1f" class="">As in the single-cycle processor, the control unit computes the control signals based on the <code>opcode</code> and <code>funct</code> fields of the instruction, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>31</mn><mo>:</mo><mn>26</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{31:26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span><span class="mrel mtight">:</span><span class="mord mtight">26</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>5</mn><mo>:</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{5:0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mrel mtight">:</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>. The figure shows the entire multicycle MIPS processor with the control unit attached to the datapath. The datapath is shown in black, and the control unit is shown in blue.</p></div><div id="fdfbccf1-d87e-4214-988d-eba47e82415b" style="width:43.75%" class="column"><figure id="40df7cc7-c501-4567-af0e-59abaae5b938" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2027.png"><img style="width:1675px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2027.png"/></a></figure></div></div><div id="c4d3b94f-9298-4371-8a2c-1def0273eff6" class="column-list"><div id="9b23eb36-a9e2-4b14-8bf1-3c861588bbb6" style="width:56.25%" class="column"><p id="26458b1b-7fbe-472b-a129-e97a1a9a1421" class="">As in the single-cycle processor, the control unit is partitioned into a main controller and an ALU decoder, as shown. The ALU decoder is unchanged and follows the truth table from the single-cycle control unit. Now however, the main controller is an FSM that applies the proper control signals on the proper cycles or steps. The sequence of control signals depends on the instruction being executed.</p><p id="01120223-dfec-4f45-b205-fd4d7a208edf" class="">The main controller produces multiplexer select and register enable signals for the datapath. The select signals are <em>MemtoReg</em>, <em>RegDst</em>, <em>IorD</em>, <em>PCSrc</em>, <em>ALUSrcA</em>, and <em>ALUSrcB</em>. The enable signals are <em>IRWrite</em>, <em>MemWrite</em>, <em>PCWrite</em>, <em>Branch</em>, and <em>RegWrite</em>.</p><p id="b96355fc-c4e4-4fa3-acf3-bfc6f313c035" class="">To keep the following state transition diagrams readable, only the relevant control signals are listed. Select signals are listed only when their value matters; otherwise, they are don’t cares. Enable signals are listed only when they are asserted; otherwise, they are 0.</p></div><div id="c6bd4a72-4851-4ece-8b54-f606f36b5d15" style="width:43.74999999999999%" class="column"><figure id="59891d75-50e7-490e-b40b-9deccdf9e636" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2028.png"><img style="width:588px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2028.png"/></a></figure></div></div><div id="349594f3-ab9e-4b38-91aa-65a1404c2308" class="column-list"><div id="0661e99e-ebc4-4876-9f33-747dc2d8ef3f" style="width:81.25%" class="column"><p id="afc14adc-4c8d-42e2-b31f-5d328b037149" class="">The first step for any instruction is to fetch the instruction from memory at the address held in the PC. The FSM enters this state on reset. To read memory, <em>IorD</em> = 0, so the address is taken from the PC. <em>IRWrite</em> is asserted to write the instruction into the instruction register, <em>IR</em>. Meanwhile, the PC should be incremented by 4 to point to the next instruction. Because the ALU is not being used for anything else, the processor can use it to compute PC + 4 at the same time that it fetches the instruction. <em>ALUSrcA</em> = 0, so <em>SrcA</em> comes from the PC. <em>ALUSrcB</em> = 01, so <em>SrcB</em> is the constant 4. <em>ALUOp</em> = 00, so the ALU decoder produces <em>ALUControl</em> = 010 to make the ALU add. To update the PC with this new value, <em>PCSrc</em> = 0, and <em>PCWrite</em> is asserted. These control signals are shown in the figure. The data flow on this step is shown below, with the instruction fetch shown using the dashed blue line and the PC increment shown using the dashed gray line.</p><figure id="f4d3ded9-f03e-4351-bd4b-bd0d6b3a2a40" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2029.png"><img style="width:1344px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2029.png"/></a></figure></div><div id="14f26298-310d-443a-a9d6-20f149b60022" style="width:18.750000000000004%" class="column"><figure id="3dc45155-2d47-4004-8b2c-1a3622912563" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2030.png"><img style="width:396px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2030.png"/></a></figure></div></div><div id="0d683ff7-7839-4509-8918-5c85161aa927" class="column-list"><div id="deb48212-d003-477e-818d-4b19d4bd52e5" style="width:62.5%" class="column"><p id="0876d49b-af07-43dd-9e80-7e5833a13085" class="">The next step is to read the register file and decode the instruction. The register file always reads the two sources specified by the <code>rs</code> and <code>rt</code> fields of the instruction. Meanwhile, the immediate is sign-extended. Decoding involves examining the <code>opcode</code> of the instruction to determine what to do next. No control signals are necessary to decode the instruction, but the FSM must wait 1 cycle for the reading and decoding to complete, as shown.  The new state is highlighted in blue. The data flow is shown below.</p><figure id="828cd56a-d14f-4847-a201-188a3f940403" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2031.png"><img style="width:1344px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2031.png"/></a></figure></div><div id="515e57e1-d34b-4767-bdea-7dfd1235ddb3" style="width:37.5%" class="column"><figure id="4e16bf4a-23b1-49d2-8ff5-5328c12a6c12" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2032.png"><img style="width:773px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2032.png"/></a></figure></div></div><div id="11eb4413-85ad-40f5-a305-b35f5e47666d" class="column-list"><div id="f69eaeaf-bea4-489b-8081-28467ab9678d" style="width:62.5%" class="column"><p id="6deddfb6-ef9a-4a8d-b591-ce7df4fa7e17" class="">Now the FSM proceeds to one of several possible states, depending on the <code>opcode</code>. If the instruction is a memory load or store, the multicycle processor computes the address by adding the base address to the sign-extended immediate. This requires <em>ALUSrcA</em> = 1 to select register <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span> and <em>ALUSrcB</em> = 10 to select <em>SignImm</em>. <em>ALUOp</em> = 00, so the ALU adds. The effective address is stored in the <em>ALUOut</em> register for use on the next step. This FSM step is shown in the figure, and the data flow is shown below.</p><figure id="392f3c3e-582a-433b-a933-3c286f1a1c63" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2033.png"><img style="width:1344px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2033.png"/></a></figure></div><div id="b691a8dc-d21d-49d9-bbf3-414d4efe2d9c" style="width:37.50000000000001%" class="column"><figure id="7d6d8dc3-0f73-4289-9dd3-fbc371ae5dbf" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2034.png"><img style="width:691px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2034.png"/></a></figure></div></div><div id="aee6d872-69bf-4f97-b090-849540e6fdab" class="column-list"><div id="28c59715-4b33-457b-9ee7-3ce066fb3452" style="width:68.75%" class="column"><p id="97a14b0c-b3e7-45f7-bf4c-dc437c8465f7" class="">If the instruction is <code>lw</code>, the multicycle processor must next read data from memory and write it to the register file. Thee two steps are shown in the figure. To read from memory, <em>IorD</em> = 1 to select the memory address that was just computed and saved in <em>ALUOut</em>. This address in memory is read and saved in the Data register during step S3. On the next step, S4, <em>Data</em> is written to the register file. <em>MemtoReg</em> = 1 to select <em>Data</em> and <em>RegDst</em> = 0 to pull the destination register from the <code>rt</code> field of the instruction. <em>RegWrite</em> is asserted to perform the write, completing the <code>lw</code> instruction. Finally, the FSM returns to the initial state, S0, to fetch the next instruction.</p></div><div id="437ad235-82ab-44f3-9d2c-962572430188" style="width:31.25%" class="column"><figure id="d85ca3fc-aa1e-4387-a545-694cc48fc1d2" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2035.png"><img style="width:1180px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2035.png"/></a></figure></div></div><div id="001c0e22-9fe6-487b-aed9-b8979759c857" class="column-list"><div id="12095f4c-730d-4cc4-a5f8-d24cd793d3e9" style="width:68.75%" class="column"><p id="4f4e1d0c-f2e7-43a4-a41d-7275fa3a2adf" class="">From state S2, if the instruction is <code>sw</code>, the data read from the second port of the register file is simply written to memory. <em>IorD</em> = 1 to select the address computed in S2 and saved in <em>ALUOut</em>. <em>MemWrite</em> is asserted to write the memory. Again, the FSM returns to S0 to fetch the next instruction. The added step is shown in the figure.</p></div><div id="090f9f0e-aabb-49b1-a924-99feddff1ec2" style="width:31.25%" class="column"><figure id="0bead524-2d64-4452-8aa7-157a4d6eab32" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2036.png"><img style="width:1160px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2036.png"/></a></figure></div></div><div id="ae41b4d7-299c-4f65-a8d4-c406a43d4719" class="column-list"><div id="f743a41c-8eb2-4e1b-8381-c30d58b45cc3" style="width:68.75%" class="column"><p id="daec0963-85f0-4330-9d85-7ef02d72b1b4" class="">If the <code>opcode</code> indicates an R-type instruction, the multicycle processor must calculate the result using the ALU and write that result to the register file. The figure shows these two steps. In S6, the instruction is executed by selecting the <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span> and <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span><span>﻿</span></span> registers and performing the ALU operation indicated by the <code>funct</code> field of the instruction. <em>ALUOp</em> = 10 for all R-type instructions. The <em>ALUResult</em> is stored in <em>ALUOut</em>. In S7, <em>ALUOut</em> is written to the register file, <em>RegDst</em> = 1, because the destination register is specified in the <code>rd</code> field of the instruction. <em>MemtoReg</em> = 0 because the write data, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WD</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">\text{WD}3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">WD</span></span><span class="mord">3</span></span></span></span></span><span>﻿</span></span>, comes from <em>ALUOut</em>. <em>RegWrite</em> is asserted to write the register file.</p></div><div id="6611a5c7-f14d-4285-b360-541e56d135f0" style="width:31.25%" class="column"><figure id="596b8c2c-d58b-42b7-a335-fae23295113c" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2037.png"><img style="width:1162px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2037.png"/></a></figure></div></div><div id="4fae7b39-4ab4-444a-802d-c4cef8228f27" class="column-list"><div id="da9f83bf-397a-46cd-bd0f-ea9df3f9077b" style="width:68.75%" class="column"><p id="76c52614-397a-4941-aa93-12bfaf7c9c8e" class="">For a <code>beq</code> instruction, the processor must calculate the destination address and compare the two source registers to determine whether the branch should be taken. This requires two uses of the ALU and hence might see to demand two new states. Notice however, that the ALU was not used during S1 when the registers were being read. The processor might as well use the ALU at that time to compute the destination address by adding the incremented PC, PC + 4, to <em>SignImm</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 4, as shown. <em>ALUSrcA</em> = 0 to select the incremented PC, <em>ALUSrcB</em> = 11 to select <em>SignImm</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 4, and <em>ALUOp</em> = 00 to add. The destination address is stored in <em>ALUOut</em>. If the instruction is not <code>beq</code>, the computed address will not be used in subsequent cycles, but its computation was harmless. In S8, the processor compares the two registers by subtracting them and checking to determine whether the result is 0. If it is, the processor branches to the address that was just computed. <em>ALUSrcA</em> = 1 to select register <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span><span>﻿</span></span>; <em>ALUSrcB</em> = 00 to select register <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span><span>﻿</span></span>; <em>ALUOp</em> = 01 to subtract; <em>PCSrc</em> = 1 to take the destination address from <em>ALUOut</em>, and <em>Branch</em> = 1 to update the PC with this address if the ALU result is 0.</p></div><div id="81a6985e-2325-4646-9259-7dc7a1bc420f" style="width:31.250000000000007%" class="column"><figure id="fe987152-309a-4497-a1f5-98ac91362b19" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2038.png"><img style="width:1187px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2038.png"/></a></figure></div></div><div id="f8efe08e-62c4-4537-b2d0-44e450a32278" class="column-list"><div id="cc3cdf69-a0ec-4f34-81e8-a66e80170c4d" style="width:68.75%" class="column"><p id="2ef92477-7071-4c7b-afde-b874d42c0348" class="">Putting these steps together, the figure shows the complete main controller state transition diagram for the multicycle processor. Converting it to hardware is a straightforward but tedious task using the techniques in <a href="Sequential%20Logic%2042c224c8465c4576ac93922cb2672120.html"><span class="icon">🎞️</span>Sequential Logic</a>. An easier way however is to code the FSM in Verilog and synthesize it using the techniques in <a href="Hardware%20Description%20Languages%20fcb219831f434191a76d1574a38442ae.html"><span class="icon">🥎</span>Hardware Description Languages</a>.</p></div><div id="63a8ef69-a7c5-4e68-8e4e-c9a256fa7af5" style="width:31.250000000000007%" class="column"><figure id="a7706250-f8d1-4a1a-bc66-81ac0721e4b0" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2039.png"><img style="width:1185px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2039.png"/></a></figure></div></div><h2 id="1b9173f2-8f42-470f-b280-107ba70e4195" class="">Performance Analysis</h2><p id="ae9dc022-0888-4344-9842-d6b3cbfd6c52" class="">The execution time of an instruction depends on both the number of cycles it uses and the cycle time. Whereas the single-cycle processor performed all instructions in one cycle, the multicycle processor uses varying numbers of cycles for the various instructions. However, the multicycle processor does less work in a single cycle and, thus, has a shorter cycle time.</p><p id="c106f58f-7776-486e-b8de-c57dae1a72cb" class="">The multicycle processor requires three cycles for <code>beq</code> instructions, four cycles for <code>sw</code>, and R-type instructions, and five cycles for <code>lw</code> instructions. The CPI depends on the relative likelihood that each instruction is used.</p><p id="d1c08914-820c-44d0-8bdb-2c7b397bdc58" class="">Recall that we designed the multicycle processor so that each cycle involved one ALU operation, memory access, or register file access. Let us assume that the register file is faster than the memory and that writing memory is faster than reading memory. Examining the datapath reveals two possible critical datapaths that would limit the cycle time: </p><figure id="8ede7c4d-6c6a-42c2-a905-5398e0f42b82" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>p</mi><mi>c</mi><mi>q</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mtext>mux</mtext></msub><mo>+</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mtext>ALU</mtext></msub><mo>+</mo><msub><mi>t</mi><mtext>mux</mtext></msub><mo separator="true">,</mo><msub><mi>t</mi><mtext>mem</mtext></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>t</mi><mtext>setup</mtext></msub></mrow><annotation encoding="application/x-tex">T_c = t_{pcq}+t_{\text{mux}}+ \max(t_{\text{ALU}} + t_{\text{mux}}, t_{\text{mem}}) + t_{\text{setup}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mux</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">ALU</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mux</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">mem</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">setup</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="a8cc1390-118e-4e5e-92cd-dc22b4c6971a" class="">The numerical values of these times will depend on the specific implementation technology.</p><h1 id="adc3671a-0d84-4305-99cf-961b9e7b0184" class="">Pipelined Processor</h1><p id="dffaba3c-ad48-494e-974d-53ec7e9d3bb0" class="">Pipelining is a powerful way to improve the throughput of a digital system. We design a pipelined processor by subdividing the single-cycle processor into five pipeline stages. Thus, five instruction can execute simultaneously, one in each stage. Because each stage has only one-fifth of the entire logic, the clock frequency is almost five times faster. Hence, the latency of each instruction is ideally unchanged, but the throughput is ideally five times better. Microprocessors execute millions or billions of instructions per second, so throughput is more important than latency. Pipelining introduces some overhead, so the throughput will not be quite as high ass we might ideally desire, but pipelining nevertheless gives such great advantage for so little cost that all modern high-performance microprocessors are pipelined.</p><p id="bdd4f942-1ee7-421e-8643-20f7fb8f0f2f" class="">Reading and writing the memory and register file and using the ALU typically constitute the biggest delays in the processor. We choose five pipeline stages so that each stage involves exactly one of these slow steps. Specifically, we call the five stages <em>Fetch</em>, <em>Decode</em>, <em>Execute</em>, <em>Memory</em>, and <em>Writeback</em>. They are similar to the five steps that the multicycle processor used to perform <code>lw</code>. In the <em>Fetch</em> stage, the processor reads the instruction to produce the control signals. In the <em>Execute</em> stage, the processor performs a computation with the ALU. In the <em>Memory</em> stage, the processor reads or writes data memory. Finally, in the <em>Writeback</em> stage, the processor writes the result to the register file, when applicable.</p><div id="eba78387-d618-47f2-b81a-96ce67c25c2f" class="column-list"><div id="720a5053-3c95-4ca0-94c8-540cb9e3dd0f" style="width:62.5%" class="column"><p id="dc53333c-1d0f-4e08-9204-69da0d7656ec" class="">The figure shows a timing diagram comparing the single-cycle and pipelined processors. Time is on the horizontal axis, and instructions are on the vertical axis. In the single-cycle processor, a), the first instruction is read from memory at time 0; next the operands are read from the register file; and then the ALU executes the necessary computation. Finally, the data memory may be accessed, and the result is written back to the register file by 950 ps. The second instruction begins when the first completes. Hence, in this diagram, the single-cycle processor has an instruction latency of 250 + 150 + 200 + 250 + 100 = 950 ps and a throughput of 1 instruction per 950 ps.</p><p id="f6959cab-7152-4efe-961c-23e38be147db" class="">In the pipelined processor, b), the length of a pipeline stage is set at 250 ps by the slowest stage, the memory access (in the Fetch or Memory stage). At time 0, the first instruction is fetched from memory. At 250 ps, the first instruction enters the Decode stage, and a second instruction is fetched. At 500 ps, the first instruction executes, the second instruction enters the Decode stage, and a third instruction is fetched. And so forth, until all the instructions complete. The instruction latency is 5 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span></span><span>﻿</span></span> 250 ps = 1250 ps. The throughput is 1 instruction per 250 ps. Because the stages are not perfectly balanced with equal amounts of logic, the latency is slightly longer for the pipelined than for the single-cycle processor. Simmilarly, the throughput is not quite five times as great for a five-stage pipeline as for the single-cycle processor. Nevertheless, the throughput advantage is substantial.</p></div><div id="61a2ece9-908b-4702-81f2-4a928d74a2bb" style="width:37.50000000000001%" class="column"><figure id="2ebde107-dbf1-4a40-b952-8b1741c36288" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2040.png"><img style="width:1885px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2040.png"/></a></figure></div></div><div id="f47d9bbf-ef55-4a5c-818f-d90daf45f3b8" class="column-list"><div id="4666e927-4fa1-4af4-bc50-f4ff4d61b908" style="width:62.5%" class="column"><p id="ebb1baad-e0fc-48e6-89f8-e7707479d4ce" class="">The figure shows an abstracted view of the pipeline in operation in which each stage is represented pictorially. Each pipeline stage is represented with its major component - instruction memory (IM), register file (RF) read, ALU execution, data memory (DM), and register file writeback - to illustrate the flow of instructions through the pipeline. Reading across a row shows the clock cycles in which a particular instruction is in each stage. For example, the <code>sub</code> instruction is fetched in cycle 3 and executed in cycle 5. Reading down a column shows what the various pipeline stages are doing on a particular cycle. For example, in cycle 6, the <code>or</code> instruction is being fetched from instruction memory, while <code>$s1</code> is being read from the register file, the ALU is computing <code>$t5</code> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AND</mtext></mrow><annotation encoding="application/x-tex">\text{AND}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">AND</span></span></span></span></span></span><span>﻿</span></span> <code>$t6</code>, the data memory is idle, and the register file is writing a sum to <code>$s3</code>. Stages are shaded to indicate when they are used. For example, the data memory is used by <code>lw</code> in cycle 4 and by <code>sw</code> in cycle 8. The instruction memory and ALU are used in every cycle. The register file is written by every instruction except <code>sw</code>. We assume that in the pipelined processor the register file is written in the first part of a cycle and read in the second part, as suggested by the shading. This way, data can be written and read back in a single cycle.</p><p id="f430f71c-6df8-4329-8856-88bf18b11697" class="">A central challenge in pipelined systems is handling <em>hazards</em> that occur when the results of one instruction are needed by a subsequent instruction before the former instruction has completed. For example, if the <code>add</code> in the figure used <code>$s2</code> instead of <code>$t2</code>, a hazard would occur because the <code>$s2</code> register has not been written by the <code>lw</code> by the time it is read by the <code>add</code>. This section explores <em>forwarding</em>, <em>stalls</em>, and <em>flushes</em> as methods to resolve hazards.</p></div><div id="e93a0f64-8b14-47ef-8a93-d2e465914b95" style="width:37.5%" class="column"><figure id="97ed853a-2c48-4a40-b97b-0ed883f33751" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2041.png"><img style="width:1670px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2041.png"/></a></figure></div></div><h2 id="fe751969-8445-4ebd-a055-5ee51dcdecb6" class="">Pipelined Datapath</h2><div id="66737ae3-1cd7-447a-96db-9ee307e80579" class="column-list"><div id="9f856361-34bd-40ae-8ec3-9cdb88aafb06" style="width:62.5%" class="column"><p id="7f776320-6efb-4de2-880f-abacca41576b" class="">The pipelined datapath is formed by chopping the single-cycle datapath into five stages separated by pipeline registers. The figure a) shows the single-cycle datapath stretched out to leave room for the pipeline registers. b) shows the pipelined datapath formed by inserting four pipeline registers to separate the datapath into five stages. The stages and their boundaries are indicated in blue. Signals are given a suffix (F, D, E, M, or W) to indicate the stage in which they reside.</p><p id="7226bb9f-7deb-49a0-8c0c-463b924a8d22" class="">The register file is peculiar because it is read in the Decode stage and written in the Writeback stage. This feedback will lead to pipeline hazards, which will be discussed later.</p><p id="5f485d19-3b50-4f7b-9d69-363999799019" class="">One of the subtle but critical issues in pipelining is that all signals associated with a particular instruction must advance through the pipeline in unison. Figure b) has an error related to this issue.</p><p id="6b4d4373-ce76-43e8-8690-cbde3d64c1e8" class="">The error is in the register file write logic, which should operate in the Writeback stage. The data value comes from <em>ResultW</em>, a Writeback stage signal. But the address comes from <em>WriteRegE</em>, an execute stage signal. In the pipeline diagram above, during cycle 5, the result of the <code>lw</code> instruction would be incorrectly written to register <code>$s4</code> rather than register <code>$s2</code>.</p></div><div id="84c1aab5-8afa-4096-8778-feb0a5e9980b" style="width:37.5%" class="column"><figure id="af35fe77-b52e-47c6-bb9a-0960bd01d086" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2042.png"><img style="width:1261px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2042.png"/></a></figure></div></div><div id="bf0babb9-481b-4106-807d-ee18e9300752" class="column-list"><div id="56414c31-5c48-49c5-978e-a81d4f6cea07" style="width:62.5%" class="column"><p id="93d9c775-cc01-4eb4-923c-e56ea2ae6434" class="">The figure shows a corrected datapath. The <em>WriteReg</em> signal is now pipelined along through the Memory and Writeback stages, so it remains in sync with the rest of the instruction. <em>WriteRegW</em> and <em>ResultW</em> are fed back together to the register file in the Writeback stage.</p><p id="9af15009-3823-4db0-8737-1c92b36b67ac" class="">The PC’ logic is also problematic, because it might be updated with a Fetch or a Memory stage signal (<em>PCPlus4F</em> or <em>PCBranchM</em>). This control hazard will be fixed later.</p></div><div id="3a1e5fbb-e80d-4d51-9a6d-3f7acc8cc7ab" style="width:37.5%" class="column"><figure id="db8ee9ff-cbe9-43f8-87a5-969d815a6037" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2043.png"><img style="width:1301px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2043.png"/></a></figure></div></div><h2 id="93d2ceda-289b-48f0-98b7-89856f62dd80" class="">Pipelined Control</h2><p id="64c031e2-2595-4ed5-9c47-cb4f1e924296" class="">The pipelined processor takes the same control signals as the single-cycle processor and therefore uses the same control unit. The control unit examines the <code>opcode</code> and <code>funct</code> fields of the instruction in the Decode stage to produce the control signals, as was described earlier. These control signals must be pipelined along with the data so that they remain synchronized with the instruction.</p><div id="33a991ca-4d2c-4daa-95f0-7866f98febb1" class="column-list"><div id="47b40d6d-18e8-4bf5-bc65-f3ba8a25f25b" style="width:62.5%" class="column"><p id="666f6945-bcd8-44f8-b0b5-67efb1796dd4" class="">The entire pipelined processor with control is shown in the figure. <em>RegWrite</em> must be pipelined into the Writeback stage before it feeds back to the register file, just as <em>WriteReg</em> was pipelined above.</p></div><div id="9688e1a1-6bf9-4801-8ae2-06a83fe3845b" style="width:37.5%" class="column"><figure id="b870e6fe-cad4-4eed-856e-7b07c2cb5bd2" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2044.png"><img style="width:1223px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2044.png"/></a></figure></div></div><h2 id="ca875ab9-8309-4a55-8f9f-362121b11ee5" class="">Hazards</h2><div id="d52bb576-eeb1-4237-8f7e-da3844c48453" class="column-list"><div id="89618c32-f6da-4f44-bdd8-6c81ce12231b" style="width:62.5%" class="column"><p id="1e7a0007-78e8-4d28-91f6-7c99f212f865" class="">In a pipelined system, multiple instructions are handled concurrently. When one instruction is <em>dependent</em> on the results of another that has not yet completed, a <em>hazard</em> occurs.</p><p id="954edc78-b70d-4758-b2c5-335866f6d650" class="">The register file can be read and written in the same cycle. Let us assume that the write takes place during the first half of the cycle and the read take place during the second half of the cycle, so that a register can be written and read back in the same cycle without introducing a hazard.</p><p id="2ccc4a86-76a0-4b95-b9c7-51d9d019709c" class="">The figure illustrates hazards that occur when one instruction writes a register (<code>$s0</code>) and subsequent instructions read this register. This is called a <em>read after write (RAW)</em> hazard. The <code>add</code> instruction writes a result into <code>$s0</code> in the first half of cycle 5. However, the <code>and</code> instruction reads <code>$s0</code> on cycle 3, obtaining the wrong value. The <code>or</code> instruction reads <code>$s0</code> on cycle 4, again obtaining the wrong value. The <code>sub</code> instruction reads <code>$s0</code> in the second half of cycle 5, obtaining the correct value, which was written in the first half of cycle 5. Subsequent instructions also read the correct value of <code>$s0</code>. The diagram shows that hazards may occur in this pipeline when an instruction writes a register and either of the two subsequent instructions read that register. Without special treadment, the pipeline will compute the wrong result.</p><p id="7c881f6a-5487-4862-a52c-d3b9f684a720" class="">On closer inspection, however, observe that the sum from the <code>add</code> instruction is computed by the ALU in cycle 3 and is not strictly needed by the <code>and</code> instruction until the ALU uses it in cycle 4. In principle, we should be able to forward the result from one instruction to the next to resolve the RAW hazard without slowing down the pipeline. In other situations explored later in this section, we may have to stall the pipeline to give time for a result to be computed before the subsequent instruction uses the result. In any event, something must be done to solve hazards so that the program executes correctly despite the pipelining.</p><p id="ec6107a4-b66c-4523-a180-6df88a99a0a7" class="">Hazards are classified as data hazards or control hazards. A <em>data hazard</em> occurs when an instruction tries to read a register that has not yet been written back by a previous instruction. A <em>control hazard</em> occurs when the decision of what instruction to fetch next has not been made by the time the fetch takes place. In the remainder of this section, we will enhance the pipelined processor with a hazard unit that detects hazards and handles them appropriately, so that the processor executes the program correctly.</p></div><div id="fbbe5a3c-d3b2-4490-8b86-a469a59a958e" style="width:37.49999999999999%" class="column"><figure id="98914fe8-9913-446c-91c0-53f5574f5d71" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2045.png"><img style="width:1060px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2045.png"/></a></figure></div></div><h3 id="ec294776-913a-4b5a-b66f-4e3a6d913aa0" class="">Solving Data Hazards with Forwarding</h3><div id="03c7f7f9-06e6-421b-8d65-984227dbe8c8" class="column-list"><div id="ed9a6fd3-b23a-4cc6-a0a8-904d4caf11a1" style="width:62.5%" class="column"><p id="859cbc33-1363-4e8a-8704-471eabdd56b0" class="">Some data hazards can be solved by <em>forwarding</em> (also called <em>bypassing</em>) a result from the Memory or Writeback stage to a dependent instruction in the Execute stage. This requires adding multiplexers in front of the ALU to select the operand from either the register file or the Memory or Writeback stage. The figure illustrates this principle. In cycle 4, <code>$s0</code> is forwarded from the memory stage of the <code>add</code> instruction to the Execute stage of the dependent <code>and</code> instruction. In cycle 5, <code>$s0</code> is forwarded from the Writeback stage of the <code>add</code> instruction to the Execute stage of the dependent <code>or</code> instruction.</p></div><div id="b4b6925b-406a-435d-96f5-3fa953065064" style="width:37.50000000000001%" class="column"><figure id="d7c03da5-5deb-44fe-907a-4b066d4dd840" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2046.png"><img style="width:1073px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2046.png"/></a></figure></div></div><div id="ade40d2a-8a96-4b83-b8a7-e527d9e763ec" class="column-list"><div id="0ba9eb78-4599-41af-97c8-ce28edb32048" style="width:62.5%" class="column"><p id="ec7fa69f-a8aa-4980-8631-fd82d6a748bd" class="">Forwarding is necessary when an instruction in the Execute stage has a source register matching the destination register of an instruction in the Memory or Writeback stage. The figure modifies the pipelined processor to support forwarding. It adds a <em>hazard detection unit</em> and two forwarding multiplexers. The hazard detection unit receives the two source registers from the instruction in the Execute stage and the destination registers from the instructions in the Memory and Writeback stages. It also receives the <em>RegWrite</em> signals from the Memory and Writeback stages to know whether the destination register will actually be written. Note that the <em>RegWrite</em> signals are <em>connected by name</em>. In other words, rather than cluttering up the diagram with long wires running from the control signals at the top to the hazard unit at the bottom, the connections are indicated by a short stub of wire labeled with the control signal name to which it is connected.</p><p id="4a499d49-3273-4eab-9c52-95de4d773247" class="">The hazard detection unit computes control signals for the forwarding multiplexers to choose operands from the register file or from the results in the Memory or Writeback stage. It should forward from a stage if that stage will write a destination register and the destination register matches the source register. However, <code>$s0</code> is hardwired to 0 and should never be forwarded. If both the memory and Writeback stages contain matching destination registers, the Memory stage should have priority because it contains the more recently executed instruction. In summary, the function of the forwarding logic for <em>SrcA</em> is given below. The forwarding logic for <em>SrcB</em> is identical except that it checks <code>rt</code> rather than <code>rs</code>.</p><pre id="0d75d2d8-3252-4f05-a5ae-77ca726d6180" class="code"><code>if ((rsE != 0) AND (rsE == WriteRegM) AND RegWriteM) then
    ForwardAE = 10
else if ((rsE != 0) AND (rsE == WriteRegW) AND RegWriteW) then
    ForwardAE = 01
else ForwardAE = 00</code></pre></div><div id="93758b69-9ec1-413a-a414-5d2b4a5779c8" style="width:37.49999999999999%" class="column"><figure id="45c83d2b-7b70-4c7e-bb48-6b6ed28c9fee" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2047.png"><img style="width:1531px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2047.png"/></a></figure></div></div><h3 id="e084575b-f249-442f-a0f1-00b2cc68bbf5" class="">Solving Data Hazards With Stalls</h3><div id="6fd21a1e-9bfa-425d-b5ac-02ebc946d931" class="column-list"><div id="1fe063ef-83bd-4d9f-8b1a-53e98a5fa761" style="width:62.5%" class="column"><p id="f9ced6d7-7ba6-4c22-bcca-7c365615477d" class="">Forwarding is sufficient to solve RAW data hazards when the result is computed in the Execute stage of an instruction, because its result can then be forwarded to the Execute stage of the next instruction. Unfortunately, the <code>lw</code> instruction does not finish reading data until the end of the Memory stage, so its result cannot be forwarded to the Execute stage of the next instruction. We say that the <code>lw</code> instruction has a <em>two-cycle latency</em>, because a dependent instruction cannot use its result until two cycles later. The figure shows this problem. The <code>lw</code> instruction receives data from memory at the end of cycle 4. But the <code>and</code> instruction needs that data as a source operand at the beginning of cycle 4. There is no way to solve this hazard with forwarding.</p></div><div id="575e8983-2058-4537-bc4a-26c266ac5696" style="width:37.5%" class="column"><figure id="69952207-69b0-43ae-b2ff-4089283e80b7" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2048.png"><img style="width:1072px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2048.png"/></a></figure></div></div><div id="ee12fe9e-c65b-448e-8eed-26671c5a502d" class="column-list"><div id="8663afc2-561c-4950-9ce0-ca30e3c91dca" style="width:62.5%" class="column"><p id="ea8e4358-8457-4da0-b85f-f52c03ee59b5" class="">The alternative solution is to <em>stall</em> the pipeline, holding up operation until the data is available. The figure shows stalling the dependent instruction (<code>and</code>) in the Decode stage. <code>and</code> enters the Decode stage in cycle 3 and stalls there through cycle 4. The subsequent instruction (<code>or</code>) must remain in the Fetch stage during both cycles as well, because the Decode stage is full.</p><p id="dad2be65-4dcf-4680-8b51-977799689a51" class="">In cycle 5, the result can be forwarded from the Writeback stage of <code>lw</code> to the Execute stage of <code>and</code>. In cycle 6, source <code>$s0</code> of the <code>or</code> instruction is read directly from the register file, with no need for forwarding.</p><p id="b84a0d97-9ce0-4277-a9e5-45aebf0fb48d" class="">Notice that the Execute stage is unused in cycle 4. Likewise, Memory is unused in cycle 5 and Writeback is unused in cycle 6. This unused stage propagating through the pipeline is called a <em>bubble</em>, and it behaves like a <code>nop</code> instruction. The bubble is introduced by zeroing out the Execute stage control signals during a Decode stall so that the bubble performs no action and changes no architectural state.</p><p id="7630b40d-0ed5-4837-bd74-f74afc33f380" class="">In summary, stalling a stage is performed by disabling the pipeline register, so that the contents do not change. When a stage is stalled, all previous stages must also be stalled, so that no subsequent instructions are lost. The pipeline register directly after the stalled stage must be cleared to prevent bogus information from propagating forward. Stalls degrade performance, so they should only be used when necessary.</p></div><div id="2c36fb04-d502-4608-9cc6-377d40b5dd94" style="width:37.5%" class="column"><figure id="4dc53653-24af-473d-877a-c583241c7fc7" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2049.png"><img style="width:1163px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2049.png"/></a></figure></div></div><div id="5b9b8403-bcc5-476d-9fd9-110135c1e45d" class="column-list"><div id="fd19c3b0-16b9-499f-98d5-580b2ab44919" style="width:62.5%" class="column"><p id="e4009dc8-8f2f-4997-a335-79af031a6fcc" class="">The figure modifies the pipelined processor to add stalls for <code>lw</code> data dependencies. The hazard unit examines the instruction in the Execute stage. If it is <code>lw</code> and its destination register (<code>rtE</code>) matches either source operand of the instruction in the Decode stage (<code>rsD</code> or <code>rtD</code>), that instruction must be stalled in the Decode stage until the source operand is ready.</p><p id="6a2459b1-688f-42b2-8c4e-a219e144d788" class="">Stalls are supported by adding enable inputs to the Fetch and Decode pipeline registers and a synchronous reset/clear input to the Execute pipeline register. When a <code>lw</code> stall occurs, <em>StallD</em> and <em>StallF</em> are asserted to force the Decode and Fetch stage pipeline registers to hold their old values. <em>FlushE</em> is also asserted to clear the contents of the Execute stage pipeline register, introducing a bubble.</p><p id="4350b2fc-ec47-46b8-82ac-c5ebd38a42ab" class="">The <em>MemtoReg</em> signal is asserted for the <code>lw</code> instruction. Hence, the logic to compute the stalls and flushes is </p><pre id="42d0a1f7-cf4a-442f-9b07-c78236949861" class="code"><code>lwstall = ((rsD == rtE) OR (rtD == rtE)) AND MemToRegE
StallF = StallD = FlushE = lwstall</code></pre></div><div id="154286b4-1fe8-4990-b502-65eb677bf96d" style="width:37.49999999999999%" class="column"><figure id="d186eb2d-f0bb-483f-b84b-173dfa97efb7" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2050.png"><img style="width:1525px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2050.png"/></a></figure></div></div><h3 id="2469c4e9-d9f8-4065-abf7-6b5825c59493" class="">Solving Control Hazards</h3><p id="4a7f8508-de7d-4d6c-ba9b-c8099541558a" class="">The <code>beq</code> instruction presents a control hazard: the pipelined processor does not know what instruction to fetch next, because the branch decision has not been made by the time the next instruction is fetched.</p><p id="dcee1b0f-bb5f-497b-8383-5705118b5f17" class="">One mechanism for dealing with the control hazard is to stall the pipeline until the branch decision is made (i.e., <em>PCSrc</em> is computed). Because the decision is made in the Memory stage, the pipeline would have to be stalled for three cycles at every branch. This would severely degrade the system performance.</p><p id="336581d0-be19-4a5f-a045-672edad6b202" class="">An alternative is to predict whether the branch will be taken and begin executing instructions based on the prediction. Once the branch decision is available, the processor can throw out the instructions if the prediction was wrong. In particular, suppose that we predict that branches are not taken and simply continue executing the program in order. If the branch should have been taken, the three instructions following the branch must be <em>flushed</em> (discarded) by clearing the pipeline registers for those instructions. These wasted instruction cycles are called the <em>branch misprediction penalty</em>.</p><div id="c255cab2-e559-4575-aa68-6bb25a1ab265" class="column-list"><div id="f83868d7-6f47-42c5-8da7-d39dcbab9309" style="width:62.5%" class="column"><p id="34f74d10-812e-48cd-b6bc-4a4f4d17c0bb" class="">The figure shows such a scheme, in which a branch from address 20 to address 64 is taken. The branch decision is not made until cycle 4, by which point the <code>and</code>, <code>or</code>, and <code>sub</code> instructions at addresses 24, 28 and 2C have already been fetched. These instructions must be flushed, and the <code>slt</code> instruction is fetched from address 64 in cycle 5. This is somewhat of an improvement, but flushing so many instructions when the branch is taken still degrades performance.</p><p id="a262649c-add7-430f-a2d7-5dad6b3948b6" class="">We could reduce the branch misprediction penalty if the branch decision could be made earlier. Making the decision simply requires comparing the values of two registers. Using a dedicated equality comparator is much faster than performing a subtraction and zero detection. If the comparator is fast enough, it could be moved back into the Decode stage, so that the operands are read from the register file and compared to determine the next PC by the end of the Decode stage.</p></div><div id="a75f92bc-add9-499e-b588-79de1c809b0c" style="width:37.5%" class="column"><figure id="cee4eb09-df52-409f-b0d7-6a228c5dbec2" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2051.png"><img style="width:1300px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2051.png"/></a></figure></div></div><div id="4a0d49e7-c031-48a6-ab06-6846a3c4adc5" class="column-list"><div id="69a57ddd-2e0e-4d45-915f-f4db63d01d68" style="width:62.5%" class="column"><p id="7b56a794-2f87-4195-a588-dada531b1765" class="">The figure shows the pipeline operation with the early branch decision being made in cycle 2. In cycle 3, the <code>and</code> instruction is flushed and the <code>slt</code> instruction is fetched. Now the branch misprediction penalty is reduced to only one instruction rather than three.</p></div><div id="39ab9756-6c78-47e6-ba35-7c465d24d82b" style="width:37.5%" class="column"><figure id="516ceb01-2a16-49ec-aecf-a4916f5cf6da" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2052.png"><img style="width:1220px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2052.png"/></a></figure></div></div><div id="cf0a4a7d-5c4d-46d9-8198-cb1704f33733" class="column-list"><div id="852c1aff-3021-47aa-bf1b-0d89fe53c154" style="width:62.5%" class="column"><p id="5544b551-06ba-4f52-8171-f8920b1a4b06" class="">The figure modifies the pipelined processor to move the branch decision earlier and handle control hazards. An equality comparator is added to the Decode stage and the <em>PCSrc</em> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AND</mtext></mrow><annotation encoding="application/x-tex">\text{AND}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">AND</span></span></span></span></span></span><span>﻿</span></span> gate is moved earlier, so that <em>PCSrc</em> can be determined in the Decoder stage rather than the Memory stage. The <em>PCBranch</em> adder must also be moved into the Decode stage so that the destination address can be computed in time. The synchronous clear input connected to <em>PCSrcD</em> is added to the Decode stage pipeline register so that the incorrectly fetched instruction can be flushed when a branch is taken.</p><p id="5d0f5f0e-9fda-42c2-9e5a-5191c3a0e168" class="">Unfortunately, the early branch decision hardware introduces a new RAW data hazard. Specifically, if one of the source operands for the branch was computed by a previous instruction and has not yet been written into the register file, the branch will read the wrong operand value from the register file. As before, we can solve the data hazard by forwarding the correct value if it is available or stalling the pipeline until the data is ready.</p></div><div id="83613897-2097-4430-814d-cbf959f2a4de" style="width:37.5%" class="column"><figure id="4daf1efe-30e0-4ee4-9e8a-491772758d4b" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2053.png"><img style="width:1504px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2053.png"/></a></figure></div></div><div id="5b08b010-66a1-43ac-8c87-dfe15b4f5ce9" class="column-list"><div id="58d04e0d-0143-46c1-a0ab-64afbbc9c099" style="width:62.5%" class="column"><p id="e8491d86-ac17-48b9-9de9-258362a6c189" class="">The figure shows the modifications to the pipelined processor needed to handle the Decode stage data dependency. If a result is in the Writeback stage, it will be written in the first half of the cycle and read during the second half, so no hazard exists. If the result of an ALU instruction is in the Memory stage, it can be forwarded to the equality comparator through two new multiplexers. If the result of an ALU instruction is in the Execute stage or the result of a <code>lw</code> instruction is in the Memory stage, the pipeline must be stalled at the Decode stage until the result is ready.</p><p id="69e74628-78e6-4d33-a04f-f4dba8e32d3b" class="">The function of the Decide stage forwarding logic is given below.</p><pre id="915e8c77-80fe-4793-b630-38ea81a2d0df" class="code"><code>ForwardAD = (rsD != 0) AND (rsD == WriteRegM) AND RegWriteM
ForwardBD = (rtD != 0) AND (rtD == WriteRegM) AND RegWriteM</code></pre><p id="a3420ed3-bf45-4da4-80dc-0709d1e1b8d8" class="">The function of the stall detection logic for a branch is given below.</p><p id="e3a7f414-8ee5-45fa-8252-b1dac1cec138" class="">The processor must make a branch decision in the Decode stage. If either of the sources of the branch depends on an ALU instruction in the Execute stage or on a <code>lw</code> instruction in the Memory stage, the processor must stall until all the sources are ready.</p><pre id="8e36a35c-aeab-4f96-a5e9-d26c155ddc61" class="code"><code>branchstall = (BranchD AND RegWriteE AND (WriteRegE == rsD OR WriteRegE == rtD)) OR (BranchD AND MemtoRegM AND (WriteRegM == rsD OR WriteRegM == rtD))</code></pre><p id="05fe9b65-a098-4cd5-a756-cb642954df87" class="">Now the processor might stall due to either a load or a branch hazard: </p><pre id="67f6ce07-45fa-4a2b-8f57-129517293c03" class="code"><code>StallF = StallD = FlushE = lwstall OR branchstall</code></pre></div><div id="d5f9dec5-8ee9-44e7-934f-7404120f4dac" style="width:37.50000000000001%" class="column"><figure id="2e645cc5-465d-406e-80e7-d13fa0d5bb94" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2054.png"><img style="width:1515px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2054.png"/></a></figure></div></div><h3 id="577ac544-b934-4ab3-a1aa-63ad0e2b7902" class="">Hazard Summary</h3><p id="ce99fbe1-423a-4cc9-839e-f05b7777171e" class="">In summary, RAW data hazards occur when an instruction depends on the result of another instruction that has not yet been written into the register file. The data hazards can be resolved by forwarding if the result is computed soon enough; otherwise they require stalling the pipeline until the result is available. Control hazards occur when the decision of what instruction to fetch has not been made by the time the next instruction must be fetched. Control hazards are solved by predicting which instruction should be fetched and flushing the pipeline if the prediction is later determined to be wrong. Moving the decision as early as possible minimizes the number of instructions that are flushed on a misprediction. </p><div id="5536e755-d8c5-46a4-8a0d-95deb118d2ae" class="column-list"><div id="52c9beb1-76fc-43b1-8f90-0b8a74482a37" style="width:62.5%" class="column"><p id="f9fac492-f5cd-495c-aa9c-88738b27877a" class="">The figure show the complete pipelined processor handling all of the hazards.</p></div><div id="553d4ec2-321d-4fb1-b24e-a119162c3759" style="width:37.50000000000001%" class="column"><figure id="e0533017-d454-4f11-b1dd-d2129dccc9ac" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2055.png"><img style="width:1523px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2055.png"/></a></figure></div></div><h2 id="e6c4ea67-ab37-4e27-8481-29f58e46b1e7" class="">Performance Analysis</h2><p id="1fe300f4-6719-4542-ac33-252cfbc0c5a8" class="">The pipelined processor ideally would have a CPI of 1, because a new instruction is issued every cycle. However, a stall or a flush wastes a cycle, so the CPI is slightly higher and depends on the specific program being executed.</p><p id="fafe7f95-a320-4fde-ac8a-7dfe6e9eb25e" class="">We can determine the cycle time by considering the critical path in each of the five pipeline stages. Recall that the register file is written in the first half of the Writeback cycle and read in the second half of the decode cycle. Therefore, the cycle time of the Decode and Writeback stages is twice the time necessary to do the half-cycle of work.</p><figure id="0ec49925-c8e7-4c88-b6ff-02c0bf9f544b" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2056.png"><img style="width:528px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2056.png"/></a></figure><p id="f010a6d7-2e94-4bcf-9b38-13ea336861a1" class="">The pipelined processor is similar in hardware requirements to the single-cycle processor, but it adds a substantial number of pipeline registers, along with multiplexers and control logic to resolve hazards.</p><h1 id="6372047d-370f-4a36-80ef-ecb47091ad17" class="">HDL Representation</h1><p id="e386cfbf-d771-45c0-ad5c-a8b867da11c3" class="">This section presents HDL code for the single-cycle MIPS processor, supporting all of the instructions discussed above, including <code>addi</code> and <code>j</code>. The code illustrates good coding practices for a moderately complex system.</p><p id="9086d476-ae03-4aba-a87e-9b6a25088e39" class="">In this section, the instruction and data memories are separated from the main processor and connected by address and data busses. This is more realistic, because most real processors have external memory. it also illustrates how the processor can communicate with the outside world.</p><div id="57fe74c6-095d-4937-95b2-da29f5f3e0f8" class="column-list"><div id="d341d84a-419e-4783-ad22-c25bbc081e34" style="width:62.5%" class="column"><p id="b3740983-84ab-4d3b-b508-baa1d49931f1" class="">The processor is composed of a datapath and a controller. The controller, in turn, is composed of the main decoder and the ALU decoder. The figure shows a block diagram of the single-cycle MIPS processor interfaced to external memories. The HDL code is partitioned into several sections.</p></div><div id="46deca50-ad97-4675-b5aa-34bc624147d1" style="width:37.5%" class="column"><figure id="7e17a829-3da2-417e-8512-47eaee7ab7a3" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2057.png"><img style="width:720px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2057.png"/></a></figure></div></div><h2 id="d2249d1f-dbbb-4cd0-bf32-92da32911b6e" class="">Single-Cycle Processor</h2><p id="59d94aec-ff0b-4c65-90ff-e3c7fe489800" class="">The main modules of the single-cycle MIPS processor module are given in the following Verilog examples. </p><h3 id="786a4457-ed1a-4af2-b4ee-0756fa3c4192" class="">Single-Cyle MIPS Processor</h3><pre id="8196a55d-7727-4617-92cf-cd1b0fc9c8a6" class="code"><code>module mips (input         clk, reset,
             output [31:0] pc,
             input  [31:0] instr,
             output        memwrite,
             output [31:0] aluwrite, writedata,
             input  [31:0] readdata);
  wire memtoreg, branch,  alusrc, regdst, regwrite, jump;
  wire [2:0] alucontrol;
  controller c (instr[31:26], instr[5:0], zero, memtoreg, memwrite, pcsrc, alusrc, regdst, regwrite, jump, alucontrol);
  datapath dp (clk, reset, memtoreg, pcsrc, alusrc, regdst, regwrite, jump, alucontrol, zero, pc, instr, aluout, writedata, readdata);
endmodule</code></pre><h3 id="5929193e-203f-4cf8-a847-03d9b2914180" class="">Controller</h3><pre id="3528941a-a808-4aa1-a6ff-1f27b216ef9a" class="code"><code>module controller (input  [5:0] op, funct,
                   input        zero,
                   output       memtoreg, memwrite,
                   output       pcsrc, alusrc,
                   output       regdst, regwrite,
                   output       jump,
                   output [2:0] alucontrol);
  wire [1:0] aluop;
  wire branch;
  maindec md (op, memtoreg, memwrite, branch, alusrc, regdst, regwrite, jump, aluop);
  aludec ad (funct, aluop, alucontrol);
  assign pcsrc = branch &amp; zero;
endmodule</code></pre><h3 id="e7fa3381-c37b-463f-b9b4-29dbd67bfbb7" class="">Main Decoder</h3><pre id="ddb01a69-2618-4001-bd0a-8eac4e2c6a29" class="code"><code>module maindec (input  [5:0] op,
                output       memtoreg, memwrite,
                output       branch, alusrc,
                output       regdst, regwrite,
                output       jump,
                output [1:0] aluop);
  reg [8:0] controls;
  assign {regwrite, regdst, alusrc, branch, memwrite, memtoreg, jump, aluop} = controls;
  always @ (*)
    case (op)
      6&#x27;b000000: controls &lt;= 9b110000010; // R-type
      6&#x27;b100011: controls &lt;= 9b101001000; // ls
      6&#x27;b101011: controls &lt;= 9b001010000; // sw
      6&#x27;b000100: controls &lt;= 9b000100001; // beq
      6&#x27;b001000: controls &lt;= 9b101000000; // addi
      6&#x27;b000010: controls &lt;= 9b000000100; // j
      default: controls &lt;= 9bxxxxxxxxx;   // ???
    endcase
endmodule</code></pre><h3 id="fea3c392-89a3-4811-b071-5068a5cff3da" class="">ALU Decoder</h3><pre id="bffdd4d6-8396-4a62-b439-ecb2a11a3ecc" class="code"><code>module aludec (input      [5:0] funct,
               input      [1:0] aluop,
               output reg [2:0] alucontrol);
  always @ (*)
    case (aluop)
      2&#x27;b00: alucontrol &lt;= 3&#x27;b010; // add
      2&#x27;b01: alucontrol &lt;= 3&#x27;b110; // sub
      default: case (funct)        // R-type
          6&#x27;b100000: alucontrol &lt;= 3&#x27;b010; // add
          6&#x27;b100010: alucontrol &lt;= 3&#x27;b110; // sub
          6&#x27;b100100: alucontrol &lt;= 3&#x27;b000; // and
          6&#x27;b100101: alucontrol &lt;= 3&#x27;b001; // or
          6&#x27;b101010: alucontrol &lt;= 3&#x27;b111; // slt
          default: alucontrol &lt;= 3&#x27;bxxx;   // ???
        endcase
    endcase
endmodule</code></pre><h3 id="533fb9f6-ff65-413d-917f-a5379f0eacab" class="">Datapath</h3><pre id="4fd65fce-e920-426d-92cb-fbe4981c20ae" class="code"><code>module datapath (input         clk, reset,
                 input         memtoreg, pcsrc,
                 input         alusrc, regdst,
                 input         regwrite, jump,
                 input  [2:0]  alucontrol,
                 output        zero,
                 output [31:0] pc,
                 input  [31:0] instr,
                 output [31:0] aluout, writedata,
                 input  [31:0] readdata);
  wire [4:0] writereg;
  wire [31:0] pcnext, pcnextbr, pcplus4, pcbranch;
  wire [31:0] signimm, signimmsh;
  wire [31:0] srca, srcb;
  wire [31:0] result;
  // next PC logic
  flopr #(32) pcreg (clk, reset, pcnext, pc);
  adder pcadd1 (pc, 32&#x27;b100, pcplus4);
  sl2 immsh (signimm, signimmsh);
  adder pcadd2 (pcplus4, signimmsh, pcbranch);
  mux2 #(32) pcbrux (pcplus4, pcbranch, pcsrc, pcnextbr);
  mux2 #(32) pcmux (pcnextbr, {pcpluss4[31:28], instr[25:0], 2&#x27;b00}, jump, pcnext);
  // register file logic
  regfile rf (clk, regwrite, instr[25:21], instr[20:16], writereg, result, srca, writedata);
  mux2 #(5) wrmux (instr[20:16], instr[15:11], regdst, writereg);
  mux2 #(32) resmux (aluout, readdata, memtoreg, result);
  signext se (instr[15:0], signimm);
  // ALU logic
  mux2 #(32) srcbmux (writedata, signimm, alusrc, srcb);
  alu alu (srca, srcb, alucontrol, aluout, zero);
endmodule</code></pre><h2 id="e1542be4-b0c2-4734-9051-c66b00b0e668" class="">Generic Building Blocks</h2><p id="84a690d4-22eb-479f-9af3-37d0dd16051a" class="">This section contains generic building blocks that may be useful in any MIPS microarchitecture, including a register file, adder, left shift unit, sign-extension unit, resettable flip-flop, and multiplexer.</p><h3 id="57f708b6-69ec-4bd7-a79d-7641a25812e6" class="">Register File</h3><pre id="287ba987-cd08-459c-94b8-4624c9696d31" class="code"><code>module regfile (input         clk,
                input         we3,
                input  [4:0]  ra1, ra2, wa3,
                input  [32:0] wd3,
                output [31:0] rd1, rd2);
  reg [31:0] rf[31:0];
  always @ (posedge clk)
    if (we3) rf[wa3] &lt;= wd3;
  assign rd1 = (ra1 != 0) ? rf[ra1] : 0;
  assign rd2 = (ra2 != 0) ? rf[ra2] : 0;
endmodule</code></pre><h3 id="d8c2d1fd-2b3b-49c9-8bb9-faab9e84f11b" class="">Adder</h3><pre id="af07472a-c194-4311-8943-8704e727f86d" class="code"><code>module adder (input  [31:0] a, b,
              output [31:0] y);
  assign y = a + b;
endmodule</code></pre><h3 id="715192a5-df34-466b-84b3-d780c923bf9a" class="">Left Shift (Multiply by 4)</h3><pre id="0b02e93e-2ce0-46be-babd-0c58a93397dd" class="code"><code>module sl2 (input  [31:0] a,
            output [31:0] y);
  // shift left by 2
  assign y = {a[29:0], 2&#x27;b00}
endmodule</code></pre><h3 id="24a94da8-0e89-4c4a-8eb1-15257efe83a9" class="">Sign Extension</h3><pre id="570c64a0-91d6-4105-adeb-15e4495f1b11" class="code"><code>module signet (input  [15:0] a,
               output [31:0] y);
  assign y = {{16{a[15]}}, a};
endmodule</code></pre><h3 id="0665aca9-3842-4535-b216-3da311696ac3" class="">Resettable Flip-Flop</h3><pre id="a25a1adc-7460-466c-bed7-1453e86bf68d" class="code"><code>module flopr #(parameter WIDTH = 8)
              (input                  clk, reset,
               input      [WIDTH-1:0] d,
               output reg [WIDTH-1:0] q);
  always @ (posedge clk, posedge reset)
    if (reset) q &lt;= 0;
    else q &lt;= d;
endmodule</code></pre><h3 id="2f7d377b-8f19-4331-9131-7215b1cda271" class="">2:1 Multiplexer</h3><pre id="ef18fb0e-0107-4a6e-a7f7-6b6958fc7e68" class="code"><code>module mux2 #(parameter WIDTH = 8)
             (input  [WIDTH-1:0] d0, d1,
              input              s,
              output [WIDTH-1:0] y);
  assign y = s ? d1 : d0;
endmodule</code></pre><h2 id="5f375333-0612-41b8-b0f8-60818bd052f1" class="">Testbench</h2><div id="5b140717-fae5-408f-be7c-6c6086015db6" class="column-list"><div id="b0106af9-a640-41a5-81e9-e2a62965b3f0" style="width:50%" class="column"><p id="804ec5d1-4c75-41cf-a5c6-349b438d83aa" class="">The MIPS testbench loads a program into the memories. The program in the figure exercises all of the instructions by performing a computation that should produce the correct answer only if all of the instructions are functioning properly. Specifically, the program will write the value 7 to address 84 if it runs correctly, and is unlikely to do so if the hardware is buggy. This is an example of <em>ad hoc</em> testing.</p><p id="0e2323b5-aa2a-4d51-a9f4-3ce62901e5ad" class="">The machine code is stored in a hexadecimal file called <code>memfile.dat</code>, which is loaded by the testbench during simulation. The file consists of the machine code for the instructions, one instruction per line.</p></div><div id="ee9d370a-f031-4396-b9d9-514914ab40af" style="width:50%" class="column"><figure id="6572e775-4c68-485d-9f19-aa85041aa6db" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2058.png"><img style="width:1205px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2058.png"/></a></figure></div></div><p id="6f2be9ea-5e27-4d28-9cbd-f7ef1a7dbe0a" class="">The testbench, top-level MIPS module, and external memory HDL code are given in the following examples. The memories in this example hold 64 words each.</p><h3 id="c9ae0377-5258-48e8-9b8f-4120514fe8cf" class="">MIPS Testbench</h3><pre id="3c5288e3-640e-4744-bd3c-2339f9d368e3" class="code"><code>module testbench ();
  reg clk;
  reg reset;
  wire [31:0] writedata, dataadr;
  wire memwrite;
  // instantiate device to be tested
  top dut (clk, reset, writedata, dataadr, memwrite);
  // initialize test
  initial
    begin
      reset &lt;= 1; # 22; reset &lt;= 0;
    end
  // alway generate clock to sequence tests
  always
    begin
      clk &lt;= 1; # 5; clk &lt;= 0; # 5;
    end
  // check results
  always @ (negedge clk)
    begin
      if (memwrite) begin
        if (dataadr === 84 &amp; writedata === 7) begin
          $display(&quot;Simulation succeeded&quot;);
          $stop;
        end else if (dataadr !== 80) begin
          $display(&quot;Simulation failed&quot;);
          $stop;
        end
      end
    end
endmodule</code></pre><h3 id="6e6f143e-201f-42b1-9524-317234008203" class="">MIPS Top-Level Module</h3><pre id="e80e5ab8-e489-4f2a-9a76-89a2e6d96180" class="code"><code>module top (input         clk, reset,
            output [31:0] writedata, dataadr,
            output        memwrite);
  wire [31:0] pc, instr, readdata;
  // instantiate processor and memories
  mips mips (clk, reset, pc, instr, memwrite, dataadr, writedata, readdata);
  imem imem (pc[7:2], instr);
  imem dmem (clk, memwrite, dataadr, writedata, readdata);
endmodule</code></pre><h3 id="54113683-72d0-46a9-b5e1-3685b790f677" class="">MIPS Data Memory</h3><pre id="d71241d6-774b-4790-b38c-c05462548b4e" class="code"><code>module dmem (input         clk, we,
             input  [31:0] a, wd,
             output [31:0] rd);
  reg [31:0] RAM[63:0];
  assign rd = RAM[a[31:2]]; // word aligned
  always @ (posedge clk)
    if (we)
      RAM[a[31:2]] &lt;= wd;
endmodule</code></pre><h3 id="2edf9025-f074-4bcf-8824-48210beee4dd" class="">MIPS Instruction Memory</h3><pre id="5d6a3a66-cf41-4d7f-8de7-5195e7cc6b39" class="code"><code>module imem (input  [5:0]  a,
             output [31:0] rd);
  reg [31:0] RAM[63:0];
  initial
    begin
      $readmemh(&quot;memfile.dat&quot;, RAM);
    end
  assign rd = RAM[a]; // word aligned
endmodule</code></pre><h1 id="e609874f-ed19-4a72-a220-2b7c97c7d205" class="">Exceptions</h1><p id="e3c83a3f-1da2-4b5d-a69a-ecfe31a6470b" class="">In this section we enhance the multicycle processor to support two types of exceptions: undefined instructions and arithmetic overflow. Supporting exceptions in other microarchitectures follows similar principles. As described previously, when an exception takes place the processor copies the PC to the EPC register and stores a code in the Cause register indicating the source of the exception. Exception causes include 0x28 for undefined instructions and 0x30 for overflow. The processor then jumps to the exception handler at memory address 0x80000180. The exception handler is code that responds to the exception. It is part of the operating system.</p><p id="130a68fe-2288-473f-95e3-5a413118108e" class="">Also, the registers are part of <em>Coprocessor 0</em>, a portion of the MIPS processor that is sued for system functions. Coprocessor 0 defines up to 32 special-purpose registers, including Cause and EPC. The exception handler may use the <code>mfc0</code> (move from coprocessor 0) instruction to copy these special-purpose registers into a general-purpose register in the register file; the Cause register is Coprocessor register 13, and EPC is register 14.</p><div id="ef58ba66-2e4e-43e7-a76e-463619bb2c31" class="column-list"><div id="5d4a3953-ddbb-4468-912d-75639f9a7406" style="width:62.5%" class="column"><p id="7be602c7-d95a-4796-9754-a1de87863983" class="">To handle exceptions, we must add EPC and Cause register to the datapath and extend the <em>PCSrc</em> multiplexer to accept the exception handler memory address, as shown. The two new registers have write enables, <em>EPCWrite</em> and <em>CauseWrite</em>, to store the PC and exception cause when an exception takes place. The cause is generated by a multiplexer that selects the appropriate code for the exception. The ALU must also generate an overflow signal, as was discussed earlier.</p></div><div id="09c54e57-8ef0-400a-bd81-fd0c6dbf7ecc" style="width:37.50000000000001%" class="column"><figure id="a9b1ed24-842e-4a12-9566-54c57452a51a" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2059.png"><img style="width:1265px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2059.png"/></a></figure></div></div><div id="3988302e-4afd-49e1-b9c6-956020ece892" class="column-list"><div id="5012ed97-f611-4e14-ac55-342cd5c11cdb" style="width:62.5%" class="column"><p id="ad384075-6a88-4656-8111-63167689a438" class="">To support the <code>mfc0</code> instruction, we also add a way to select the Coprocessor 0 registers and write them to the register file, as shown. The <code>mfc0</code> instruction specified the Coprocessor 0 register by <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Instr</mtext><mrow><mn>15</mn><mo>:</mo><mn>11</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Instr}_{15:11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Instr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span><span class="mrel mtight">:</span><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>; in this diagram, only the Cause and EPC registers are supported. We add another input to the <em>MemtoReg</em> multiplexer to select the value from Coprocessor 0.</p></div><div id="1cfa5451-0035-40c6-9f09-fbdcbc85e3bc" style="width:37.50000000000001%" class="column"><figure id="a24584db-fd64-41ca-b1ea-0d8770a8a32c" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2060.png"><img style="width:1262px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2060.png"/></a></figure></div></div><div id="22b401bb-bd08-4c5a-8a95-035814f1b2b3" class="column-list"><div id="5a5b2c9d-afb9-4d94-8f4c-2842e4f19088" style="width:62.5%" class="column"><p id="64fca981-506f-4549-84a1-915ad8fa0769" class="">The modified controller is shown in the figure. The controller receives the overflow flag from the ALU. It generates three new control signals; one to write the EPC, a second to write the Cause register, and a third to select the Cause. It also includes two new states to support the two exceptions and another state to handle <code>mfc0</code>.</p><p id="902da95e-d95c-44a2-82af-3351cf696fb8" class="">If the controller receives an undefined instruction, it proceeds to S12, saves the PC in EPC, writes 0x28 to the Cause register, and jumps to the exception handler. Similarly, if the controller detects arithmetic overflow on an <code>add</code> or <code>sub</code> instruction, it proceeds to S13, saves the PC in EPC, writex 0x30 in the Cause register, and jumps to the exception handler. Note that, when an exception occurs, the instruction is discarded and the register file is not written. When a <code>mfc0</code> instruction is decoded, the processor goes to S14 and writes the appropriate Coprocessor 0 register to the main register file.</p></div><div id="68aebe9f-f982-4edf-9b8e-0ea4c3009525" style="width:37.5%" class="column"><figure id="f812f9b9-2d58-4a22-bb9a-9dda68d3c59f" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2061.png"><img style="width:1266px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2061.png"/></a></figure></div></div><h1 id="7621e8ed-f605-461f-9061-5143ff6e637d" class="">Advanced Microarchitecture</h1><p id="27d2be76-9a6c-40b4-940d-163e701a8f2b" class="">High-performance microprocessors use a wide variety of techniques to run programs faster. Recall that the time required to run a program is proportional to the period of the clock and to the number of clock cycles per instruction (CPI). Thus, to increase performance we would like to speed up the clock and/or reduce the CPI.</p><p id="4c43f4c5-f0d3-4e7d-bdf7-bcbda0ccf7ba" class="">A manufacturing process is characterized by its <em>feature size</em>, which indicates the smallest transistor that can be reliably built. Smaller transistors are faster and generally consume less power. Thus, even if the microarchitecture does not change, the clock frequency can increase because all the gates are faster. Moreover, smaller transistors enable placing more transistors on a chip. Microarchitects use the additional transistors to build more complicated processors or to put more processors on a chip. Unfortunately, power consumption increases with the number of transistors and the speed at which they operate. Power consumption is now an essential concern. Microprocessor designers have a challenging task juggling the trade-offs among speed, power, and cost for chips with billions of transistors in some of the most complex systems that humans have ever built.</p><h2 id="ba119328-337c-45bb-a624-15c50361fdca" class="">Deep Pipelines</h2><p id="542d4d8a-e006-41af-85f7-5d0ac8479898" class="">Aside from advances in manufacturing, the easiest way to speed up the clock is to chop the pipeline into more stages. Each stage contains less logic, so it can run faster. This chapter has considered a classic five-stage pipeline, but 10 to 20 stages are now commonly used.</p><p id="8f0f920b-f95f-4b74-9afe-0b1cfda4cc7e" class="">The maximum number of pipeline stages is limited by pipeline hazards. sequencing overhead, and cost. Longer pipelines introduce more dependencies. Some of the dependencies can be solved by forwarding, but others require stalls, which increase the CPI. The pipeline registers between each stage have sequencing overhead from their setup time and clock-to-<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span></span><span>﻿</span></span> delay (as well as clock skew). This sequencing overhead makes adding more pipeline stages give diminishing returns. Finally, adding more stages increases the cost because of the extra pipeline registers and hardware required to handle hazards. </p><figure id="8fbba98b-40a1-4f9c-9902-98c0c5df8d30" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2062.png"><img style="width:507px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2062.png"/></a></figure><h2 id="9851a046-38f5-48e5-8a9d-f70c0802d484" class="">Branch Prediction</h2><p id="be3641fa-52e7-4857-9d34-3e3d3a941f70" class="">An ideal pipelined processor would have a CPI of 1. The branch misprediction penalty is a major reason for increased CPI. As pipelines get deeper, branches are resolved later in the pipeline. Thus, the branch misprediction penalty gets larger, because all the instructions issued after the mispredicted branch must be flushed. To address this problem, most pipelined processors use a <em>branch predictor</em> to guess whether the branch should be taken. Our pipeline from before simply predicted that branches are never taken.</p><p id="39182cac-6b58-4076-83d5-62adc088eba8" class="">Some branches occur when a program reaches the end of a loop and branches back to repeat the loop. Loops tend to be executed many times, so these backward branches are usually taken. The simplest form of branch prediction checks the direction of the branch and predicts that backward branches should be taken. This is called <em>static branch prediction</em>, because it does not depend on the history of the program.</p><p id="d257f390-4cc3-4039-ac7f-85120dcc2df2" class="">Forward branches are difficult to predict without knowing more about the specific program. Therefore, most processors use <em>dynamic branch predictors</em>, which use the history of program execution to guess whether a branch should be taken. Dynamic branch predictors maintain a table of the last several hundred (or thousand) branch instructions that the processor has executed. The table, sometimes called a <em>branch target buffer</em>, includes the destination of the branch and a history of whether the branch was taken.</p><p id="edfd7214-fd69-4cef-8912-b3aa56480d82" class="">To see the operation of dynamic branch predictors let us consider the following loop code. </p><pre id="f04f152f-6534-4da6-bf95-3bf92640ab78" class="code"><code>  add $s1, $0, $0
  add $s0, $0, $0
  addi $t0, $0, 10 
for:
  beq $s0, $t0, done
  add $s1, $s1, $s0
  addi $s0, $s0, 1
  j for
done:</code></pre><p id="aa709a4d-aeb1-4bf4-b1e8-36eb11952a7c" class="">A <em>one-bit dynamic branch predictor</em> remembers whether the branch was taken the last time and predicts that it will do the same thing the next time. While the loop is repeating, it remembers that <code>beq</code> was not taken last time and predicts that it should not be taken next time. This is a correct prediction until the last branch of the loop, when the branch does not get taken. Unfortunately, if the loop is run again, the branch predictor remembers that the last branch was taken. Therefore, it incorrectly predicts that the branch should be taken when the loop is first run again. In summary, a 1-bit branch predictor mispredicts the first and last branches of a loop.</p><div id="3565f4ce-2e57-4588-8f51-abbc2ec19cc6" class="column-list"><div id="b6d7d3a2-3ae9-4f5a-bd51-3de6f36d2466" style="width:62.5%" class="column"><p id="01bb05eb-666a-4173-a6d2-46f90c82ff86" class="">A 2-bit dynamic branch predictor solves this problem by having four states: <em>strongly taken</em>, <em>weakly taken</em>, <em>weakly not taken</em>, and <em>strongly not taken</em>, as shown. When the loop is repeating, it enters the <em>strongly not taken</em> state and predicts that the branch should not be taken next time. This is correct until the last branch of the loop, which is taken and moves the predictor to the <em>weakly not taken</em> state. When the loop is first run again, the branch predictor correctly predicts that the branch should not be taken and reenters the <em>strongly not taken</em> state. In summary, a 2-bit branch predictor mispredicts only the last branch of a loop.</p><p id="09be6617-1bfd-48b9-921c-650abbdd98ff" class="">As one can imagine, branch predictors may be used to track even more history of the program to increase the accuracy of predictions. Good branch predictors achieve better than 90% accuracy on typical programs.</p><p id="235985b2-242a-428d-8946-6ef2612a587b" class="">The branch predictor operates in the Fetch stage of the pipeline so that it can determine which instruction to execute on the next cycle. When it predicts that the branch should be taken, the processor fetches the next instruction from the branch destination stored in the branch target buffer. By keeping track of both branch and jump destinations in the branch target buffer, the processor can also avoid flushing the pipeline during jump instructions.</p></div><div id="d9a8fdd6-cc1e-4bdc-a85e-9c8f06eb1716" style="width:37.5%" class="column"><figure id="5916f524-ceef-4e2d-bcc2-d3f98e6b2a44" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2063.png"><img style="width:1060px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2063.png"/></a></figure></div></div><h2 id="af82484a-df23-4c3e-9470-e7bff36a8d12" class="">Superscalar Processor</h2><div id="d46fd60c-2ef0-40df-b9e2-81886ffea1d3" class="column-list"><div id="ca021604-7118-4b23-a6f6-ef26a6daf89a" style="width:62.5%" class="column"><p id="9d6ec9c4-9c38-4b12-8a2d-be7bd0289e7a" class="">A <em>superscalar processor</em> contains multiple copies of the datapath hardware to execute multiple instructions simultaneously. The figure shows a block diagram of a two-way superscalar processor that fetches and executes two instructions per cycle. The datapath fetches two instructions at a time from the instruction memory. It has a six-ported register file to read four source operands and write two results back in each cycle. it also contains two ALUs and a two-ported data memory to execute the two instructions at the same time.</p></div><div id="571cb0de-35fe-4f6d-836e-18add9d54329" style="width:37.5%" class="column"><figure id="d1ff4710-a123-4b64-93b1-b3ba195bd6e1" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2064.png"><img style="width:1635px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2064.png"/></a></figure></div></div><div id="04465ff5-5a2b-4f36-93bc-70d0432a139f" class="column-list"><div id="33a2f65d-78e5-4ff2-a232-63cefff5bc09" style="width:62.5%" class="column"><p id="7527ff32-6b59-4eb8-97ca-4fea4b704186" class="">The figure shows a pipeline diagram illustrating the two-way superscalar processor executing two instructions on each cycle. For this program, the processor has a CPI of 0.5. Designers commonly refer to the reciprocal of the CPI as the <em>instructions per cycle</em>, or IPC. This processor has an IPC of 2 on this program.</p></div><div id="91f9e745-57dd-4c5a-a0db-34203d5c689b" style="width:37.49999999999999%" class="column"><figure id="cdf1c5bb-7d64-4315-91ae-ceec7c21352e" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2065.png"><img style="width:1535px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2065.png"/></a></figure></div></div><div id="8f0a509a-a470-4faf-a893-dbf5db487bd5" class="column-list"><div id="9ca8c7c4-cdf6-4dfe-8755-905a2c1176f5" style="width:62.5%" class="column"><p id="60a87d44-dbdc-4a21-975d-1049ff510f36" class="">Executing many instructions simultaneously is difficult because of dependencies. For example, the figure shows a pipeline diagram running a program with data dependencies. The dependencies in the code are shown in blue. The <code>add</code> instruction is dependent on <code>$t0</code>, which is produced by the <code>lw</code> instruction, so it cannot be issued at the same time as <code>lw</code>. Indeed, the <code>add</code> instruction stalls for yet another cycle so that <code>lw</code> can forward <code>$t0</code> to <code>add</code> in cycle 5. The other dependencies (between <code>sub</code> and <code>and</code> based on <code>$t0</code>, and between <code>or</code> and <code>sw</code> based on <code>$t3</code>) are handled by forwarding results produced in one cycle to be consumed in the next. This program, also given below, requires five cycles to issue six instructions, for an IPC of 1.17.</p><pre id="c953b246-fcf0-43b9-9b09-fb4034652130" class="code"><code>lw $t0, 40($s0)
add $t1, $t0, $s1
sub $t0, $s2, $s3
and $t2, $s4, $t0
or $t3, $s5, $s6
sw $s7, 80($t3)</code></pre><p id="f37ac777-d7c9-4112-ac8e-05e1af49a2c7" class="">Recall that parallelism comes in temporal and spatial forms. Pipelining is a case of temporal parallelism. Multiple execution units is a case of spatial parallelism. Superscalar processors exploit both forms of parallelism to squeeze out performance far exceeding that of our single-cycle and multicycle processors.</p><p id="1f9b2016-15a9-4938-acc1-fc48e616c61e" class="">Commercial processors may be three-, four-, or even six-way superscalar. They must handle control hazards such as branches as well as data hazards. Unfortunately, real programs have many dependencies, so wide superscalar processors rarely fully utilize all of the execution units. Moreover, the large number of execution units and complex forwarding networks consume vast amounts of circuitry and power.</p></div><div id="b678be5c-93d1-4224-bdab-13aa29cd2d6e" style="width:37.5%" class="column"><figure id="9f363cf6-1c54-4249-90ed-6ed1275cec3c" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2066.png"><img style="width:1713px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2066.png"/></a></figure></div></div><h2 id="b760bca4-c34d-41c0-8455-51fa1122625d" class="">Out-of-Order Processor</h2><p id="9e6806d6-3a02-4545-805f-ed64da29d126" class="">To cope with the problem of dependencies, an <em>out-of-order processor</em> looks ahead across many instructions to <em>issue</em> independent instructions as rapidly as possible. The instructions can be issued in a different order than that written by the programmer, as long as dependencies are honored so that the program produces the intended result.</p><div id="e1359633-5ad9-4985-b4ac-8d26e5355ad4" class="column-list"><div id="9383bc03-0e99-4acd-96c1-c0c5878a65fc" style="width:62.5%" class="column"><p id="97a9def4-bd0b-429e-96a6-3174a70f509d" class="">Consider running the same program from above on a two-way superscalar out-of-order processor. The processor can issue up to two instructions per cycle from anywhere in the program, as long as dependencies are observed. The figure shows the data dependencies and the operation of the processor. The classifications of dependencies as RAW and WAR will be discussed shortly. The constraints on issuing instructions are described below.</p><ul id="8b21cd2c-e821-482b-901c-db0bda2932a2" class="bulleted-list"><li style="list-style-type:disc">Cycle 1<ul id="35414e5c-7221-4772-9339-2cfbb2234749" class="bulleted-list"><li style="list-style-type:circle">The <code>lw</code> instruction issues.</li></ul><ul id="d843dae5-43c6-4468-9e6f-049488847b49" class="bulleted-list"><li style="list-style-type:circle">The <code>add</code>, <code>sub</code>, and <code>and</code> instructions are dependent on <code>lw</code> by way of <code>$t0</code>, so they cannot issue yet. However, the <code>or</code> instruction is independent, so it also issues.</li></ul></li></ul><ul id="2ca701ec-8fdd-4b67-b421-e32931a25914" class="bulleted-list"><li style="list-style-type:disc">Cycle 2<ul id="c6e179c7-c912-4134-8e5d-04c0878e2bd9" class="bulleted-list"><li style="list-style-type:circle">Remember, that there is a two-cycle latency between when a <code>lw</code> instruction issues and when a dependent instruction can use its result, so <code>add</code> cannot issue yet because of the <code>$t0</code> dependence. <code>sub</code> writes <code>$t0</code>, so it cannot issue before <code>add</code>, lest <code>add</code> receive the wrong value of <code>$t0</code>. <code>and</code> is dependent on <code>sub</code>.</li></ul><ul id="c947148c-ccbb-46a1-bb34-150648fd12bd" class="bulleted-list"><li style="list-style-type:circle">Only the <code>sw</code> instruction issues.</li></ul></li></ul><ul id="bbd7189c-b537-4329-9a79-eaec66dc7a4b" class="bulleted-list"><li style="list-style-type:disc">Cycle 3<ul id="fa755a98-1907-4269-8041-b556a8fa34ea" class="bulleted-list"><li style="list-style-type:circle">On cycle 3, <code>$t0</code> is available, so <code>add</code> issues. <code>sub</code> issues simultaneously, because it will not write <code>$t0</code> until after <code>add</code> consumes <code>$t0</code>.</li></ul></li></ul><ul id="f0a1d91b-4c48-4757-8f3d-95b42f41d51d" class="bulleted-list"><li style="list-style-type:disc">Cycle 4<ul id="56d6f1ea-8851-40f7-8545-40cc634f4db1" class="bulleted-list"><li style="list-style-type:circle">The <code>and</code> instruction issues. <code>$t0</code> is forwarded from <code>sub</code> to <code>and</code>.</li></ul></li></ul><p id="2aa9ff3a-0992-430a-9778-31a1aaae5823" class="">The out-of-order processor issues the six instructions in four cycles, for an IPC of 1.5.</p></div><div id="35ac921a-a6ea-47e9-b3ee-926a6c1a118f" style="width:37.5%" class="column"><figure id="b8c90f10-dcbe-419b-9f09-4e933331b94a" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2067.png"><img style="width:1659px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2067.png"/></a></figure></div></div><p id="a8700447-ee87-4891-9fa6-c7feefa6748a" class="">The dependence of <code>add</code> on <code>lw</code> by way of <code>$t0</code> is a read after write hazard (RAW). <code>add</code> must not read <code>$t0</code> until after <code>lw</code> has written it. This is the type of dependency we are accustomed to handling in the pipelined processor. It inherently limits the speed at which the program can run, even if infinitely many execution units are available. Similarly, the dependence of <code>sw</code> on <code>or</code> by way of <code>$t3</code> and of <code>and</code> on <code>sub</code> by way of <code>$t0</code> are RAW dependencies.</p><p id="45186944-264c-4786-85fb-6711804c1824" class="">The dependence between <code>sub</code> and <code>add</code> by way of <code>$t0</code> is called a <em>write after read (WAR)</em> hazard, or an <em>antidependence</em>. <code>sub</code> must not write <code>$t0</code> before <code>add</code> reads <code>$t0</code>, so that <code>add</code> receives the correct value according to the original order of the program. WAR hazards could not occur in the simple MIPS pipeline, but they may happen in an out-of-order processor if the dependent instruction (<code>sub</code> in this case) is moved too early.</p><p id="1e2a00e0-0e6c-4dec-bd3e-b67df85e0c5f" class="">A WAR hazard is not essential to the operation of the program. It is merely an artifact of the programmer’s choice to use the same register for two unrelated instructions. If the <code>sub</code> instruction had written <code>$t4</code> instead of <code>$t0</code>, the dependency would disappear and <code>sub</code> could be issued before <code>add</code>. The MIPS architecture only has 32 registers, so sometimes the programmer is forced to reuse a register and introduce a hazard just because all the other registers are in use.</p><p id="d69403dd-860d-4cc9-9f51-deb746fdd2e5" class="">A third type of hazard, not shown in the program, is called <em>write after write (WAW)</em> or an <em>output dependence</em>. A WAW hazard occurs if an instruction attempts to write a register after a subsequent instruction has already written it. The hazard would result in the wrong value being written to the register. For example, in the following program, <code>add</code> and <code>sub</code> both write <code>$t0</code>. The final value in <code>$t0</code> should come from <code>sub</code> according to the order of the program. If an out-of-order processor attempted to execute <code>sub</code> first, the WAW hazard would occur.</p><pre id="4466032a-cb94-4437-ab71-364853e836a1" class="code"><code>add $t0, $s1, $s2
sub $t0, $s3, $s4</code></pre><p id="f1f0604b-5cdf-4827-b309-118d8f0b1a8d" class="">WAW hazards are not essential either; again, they are artifacts caused by the programmer’s using the same register for two unrelated instructions. If the <code>sub</code> instruction were issued first, the program could eliminate the WAW hazard by discarding the result of the <code>add</code> instead of writing it to <code>$t0</code> this is called <em>squashing</em> the <code>add</code>.</p><p id="a3130d8b-8ebe-4ffc-89e5-e5d3c09bb8a7" class="">Out-of-order processors use a table to keep track of instructions waiting to issue. The table, sometimes called a <em>scoreboard</em>, contains information about the dependencies. The size of the table determines how many instructions can be considered for issue. On each cycle, the processor examines the table and issues as many instructions as it can, limited by the dependencies and by the number of execution units that are available.</p><p id="4b9e6885-15d6-4311-beba-7ab9ffbbab00" class="">The <em>instruction level parallelism (ILP)</em> is the number of instructions that can be executed simultaneously for a particular program and microarchitecture. Theoretical studies have shown that the ILP can be quite large for out-of-order microarchitectures with perfect branch predictors and enormous amounts of execution units. However, practical processors seldom achieve an ILP greater than 2 or 3, even with six way superscalar datapaths with out-of-order execution.</p><h2 id="4668f61f-c2e7-437e-b7d8-21c38e3284d9" class="">Register Renaming</h2><p id="8b8a3591-79b6-4b29-b891-a7265620a6ca" class="">Out-of-order processors use a technique called <em>register renaming</em> to eliminate WAR hazards. Register renaming adds some nonarchitectural <em>renaming registers</em> to the processor. For example, a MIPS processor might add 20 renaming registers, called <code>$r0 - $r19</code>. The programmer cannot use these registers directly, because they are not part of the architecture. However, the processor is free to use them to eliminate hazards.</p><p id="a8cf0217-ffe7-480c-ab9e-5e0fed589ca1" class="">For example, in the previous section, a WAR hazard occurred between the <code>sub</code> and <code>add</code> instructions based on reusing <code>$t0</code>. The out-of-order processor could rename <code>$t0</code> to <code>$r0</code> for the <code>sub</code> instruction. Then <code>sub</code> could be executed sooner, because <code>$r0</code> has no dependency on the <code>add</code> instruction. The processor keeps a table of which registers were renamed so that it can consistently rename registers in subsequent dependent instructions. In this example, <code>$t0</code> must also be renamed to <code>$r0</code> in the <code>and</code> instruction, because it refers to the result of <code>sub</code>.</p><div id="6c6fcb25-8b3c-4336-9a16-edf0ca84e1f9" class="column-list"><div id="111b1389-fb8a-4ee7-a5ed-1881e61463ea" style="width:62.5%" class="column"><p id="5bf0bcc7-0bdd-4297-80ab-3a6d2e1298a8" class="">The figure shows the same program from above executing on an out-of-order processor with register renaming. <code>$t0</code> is renamed to <code>$r0</code> in <code>sub</code> and <code>and</code> to eliminate the WAR hazard. The constraints on issuing instructions are described below.</p><ul id="86a3ae25-b171-4a17-9ad5-bfef7e138228" class="bulleted-list"><li style="list-style-type:disc">Cycle 1<ul id="b9de3288-dce9-4914-a783-e461b77ded94" class="bulleted-list"><li style="list-style-type:circle">The <code>lw</code> instruction issues.</li></ul><ul id="988b5e6b-c801-47c0-a923-bc3cfde17611" class="bulleted-list"><li style="list-style-type:circle">The <code>add</code> instruction is dependent on <code>lw</code> by way of <code>$t0</code>, so it cannot issue yet. However, the <code>sub</code> instruction is independent now that its destination has been renamed to <code>$r0</code>, so <code>sub</code> also issues.</li></ul></li></ul><ul id="9c546368-eb5a-4c2e-90d4-be504a0bac43" class="bulleted-list"><li style="list-style-type:disc">Cycle 2<ul id="124d878e-d524-4dc3-bb1d-aaa9068147a1" class="bulleted-list"><li style="list-style-type:circle">Remember that there is a two-cycle latency between when a <code>lw</code> issues and when a dependent instruction can use its result, so <code>add</code> cannot issue yet because of the <code>$t0</code> dependence.</li></ul><ul id="80e8e225-ba81-461b-b8ad-8ad3a66f0bb6" class="bulleted-list"><li style="list-style-type:circle">The <code>and</code> instruction is dependent on <code>sub</code>, so it can issue. <code>$r0</code> is forwarded from <code>sub</code> to <code>and</code>.</li></ul><ul id="24364ddf-88f5-4a47-9068-fcf3f4baf56f" class="bulleted-list"><li style="list-style-type:circle">The <code>or</code> instruction is independent, so it also issues.</li></ul></li></ul><ul id="3cef9632-ec38-4f61-9cda-714f2f9fd67c" class="bulleted-list"><li style="list-style-type:disc">Cycle 3<ul id="13013572-0a94-47d1-931f-ac83e5dfded5" class="bulleted-list"><li style="list-style-type:circle">On cycle 3, <code>$t0</code> is available, so <code>add</code> issues. <code>$t3</code> is also available, so <code>sw</code> issues.</li></ul></li></ul><p id="a4971c58-5d7e-4a78-a686-63e39ce9bc4a" class="">The out-of-order processor with register renaming issues the six instructions in three cycles, for an IPC of 2.</p></div><div id="58adb005-5932-4c48-9478-e541026a53bc" style="width:37.5%" class="column"><figure id="7067ea65-6a99-40bb-8b29-d021296ea2e0" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2068.png"><img style="width:1429px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2068.png"/></a></figure></div></div><h2 id="57535c93-3083-4b2b-b97a-c0e2245c4bc8" class="">Single Instruction Multiple Data</h2><p id="a35bac66-073c-43ee-8724-6d66a1a572b8" class="">The term <em>SIMD</em> stands for <em>single instruction multiple data</em>, in which a single instruction acts on multiple pieces of data in parallel. A common application of SIMD is to perform many short arithmetic operations at once, especially for graphics processing. This is also called <em>packed</em> arithmetic.</p><div id="d0f96959-57a7-410f-8c48-6e02758fe717" class="column-list"><div id="73cdfea9-d242-4d2c-9f6b-d8d0d757802e" style="width:62.5%" class="column"><p id="96011f94-74bd-4def-aa66-5237e4264ce3" class="">For example, a 32-bit microprocessor might pack four 8-bit data elements into one 32-bit word. Packed add and subtract instructions operate on all four data elements withing the word in parallel. The figure shows a packed 8-bit addition summing four pairs of 8-bit numbers to produce four results. The word could also be divided into two 16-bit elements. Performing packed arithmetic requires modifying the ALU to eliminate carries between the smaller data elements. For example, a carry out of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0+b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> should not affect the result of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1 + b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>.</p><p id="12adccb9-3578-4e85-9f36-74a350d4c02a" class="">Short data elements often appear in graphics processing. For example, a pixel in a digital photo may use 8 bits to store each of the red, green, and blue color components. Using an entire 32-bit word to process one of these components wastes the upper 24 bits. When the components from four adjacent pixels are packed into a 32-bit word, the processing can be performed four times faster.</p><p id="ac9cfba6-12a8-475a-8a67-4004bd67ddc2" class="">SIMD instructions are even more helpful for 64-bit architectures, which can pack eight 8-bit elements, four 16-bit elements or two 32-bit elements into a single 64-bit word. SIMD instructions are also used for floating-point computations; for example, four 32-bit single-precision floating-point values can be packed into a single 128-bit word.</p></div><div id="d43f1895-b2de-47de-af6b-48cfc31797c4" style="width:37.5%" class="column"><figure id="0ef9c534-5b5f-4e92-add3-f12219864ffc" class="image"><a href="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2069.png"><img style="width:837px" src="Microarchitecture%20(TODO)%2061c2421c67e9433fbf8f28fd8b8099f8/Untitled%2069.png"/></a></figure></div></div><h2 id="0dc32615-0fee-478b-bf4d-f227e058673d" class="">Multithreading</h2><p id="db825105-535c-4399-ac72-dd6614f38b77" class="">Because the ILP of real programs tends to be fairly low, adding more execution units to a superscalar or out-of-order processor gives diminishing returns. Another problem is that memory is much slower than the processor. Most loads and stores access a smaller and faster memory, called a <em>cache</em>. However, when the instructions or data are not available in the cache, the processor may stall for 100 or more cycles while retrieving the information from the main memory. Multithreading is a technique that helps keep a processor with many execution units busy even if the ILP of a program is low or the program is stalled waiting for memory.</p><p id="66dfd3a2-fdd1-4935-8a1d-150eb25a7524" class="">To explain multithreading, we need to define a few new terms. A program running on a computer is called a <em>process</em>. Computers can run multiple processes simultaneously; for example, you can play music on a PC while surfing the web and running a virus checker. Each process consists of one or more <em>threads</em> that also run simultaneously. For example, a word processor may have one thread handling the user typing, a second thread spell-checking the document while the user works, and a third thread printing the document. In this way, the user does not have to wait, for example, for a document to finish printing before being able to type again.</p><p id="a802a8d4-0ae4-465a-be20-e1cd338d2fea" class="">In a conventional processor, the threads only give the illusion of running simultaneously. The threads actually take turns being executed on the processor under control of the OS. When one thread’s turn ends, the OS saves its architectural state, loads the architectural state of the next thread, and starts executing that next thread. This procedure is called <em>context switching</em>. As long as the processor switches through all the threads fast enough, the user perceives all of the threads as running at the same time.</p><p id="b1e61320-9d22-40ec-8aeb-2e2d76fcf3c1" class="">A multithreaded processor contains more than one copy of its architectural state, so that more than one thread can be active at a time. For example, if we extended a MIPS processor to have four program counters and 128 registers, four threads could be available at one time. If one thread stalls while waiting for the data from main memory, the processor could context switch to another thread without any delay, because the program counter and registers are already available. Moreover, if one thread lacks sufficient parallelism to keep all the execution units busy, another thread could issue instructions to the idle units.</p><p id="ef6efd59-7026-4c7e-b51e-82eb70cd37f1" class="">Multithreading does not improve the performance of an individual thread, because it does not increase the ILP. However, it does improve the overall throughput of the processor, because multiple threads can use processor resources that would have been idle when executing a single thread. Multithreading is also relatively inexpensive to implement, because it replicates only the PC and register file, not the execution units and memories.</p><h2 id="edcb45e0-fac9-4faf-8c7a-4015c349267c" class="">Multiprocessors</h2><p id="56a10b96-a222-4ce5-8b03-bc31cd447180" class="">A <em>multiprocessor</em> system consists of multiple processors and a method for communication between the processors. A common form of multiprocessing in computer systems is <em>symmetric multiprocessing (SMP)</em>, in which two or more identical processors share a single main memory.</p><p id="acd4f8e9-e397-48ec-9753-ebf7a4d2264d" class="">The multiple processors may be separate chips or multiple <em>cores</em> on the same chip. Modern processors have enormous numbers of transistors available. Using the to increase the pipeline depth or to add more execution units to a superscalar processor gives little performance benefit and is a waste of power. Around the year 2005, computer architects made a major shift to build multiple copies of the processor on the same </p><h1 id="07c4eb0f-18e3-4319-aa76-bb6b439696f5" class="">IA-32 Microarchitecture</h1></div></article></body></html>